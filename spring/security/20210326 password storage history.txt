密码存储历史
20210326
    多年来,存储密码的标准机制发展演变.开始密码明文存储.因为密码数据储在需要凭证访问地方,所以认
为密码是安全.然而,恶意用户能找到方法,获取大量用户密码数据,使用SQL注入之类攻击.越来越多安全专家
意识到需要做更多的事情来保护用户密码.
    开发者被鼓励使用单向散列(如SHA-256)计算获取密码散列码后保存.当用户尝试身份验证,密码的散列
码同输入的密码的散列码比较.这意味着系统仅需要存储单向散列码.如果发生了破坏,也仅暴露散列码.由于
散列码是单向并且很难通过散列码猜测计算密码,计算出系统的每个密码就变得毫无价值.而攻击者为了对抗
建立了已知的彩虹表.与每次猜测一个密码不同,其每一次计算一个密码的散列码,并保存到查询表.
    为了降低彩虹表的有效性,开发者使用了加盐密码.为每一个用户密码生成随机的bytes值(称为盐),使用
盐加密码的值再计算散列码.盐以明文形式存储在用户密码边上.唯一的盐让彩虹表不再有效,因为每个盐合并
密码的散列码都是不同的.
    现在我们意识到加密的散列码(如SHA-256)不再安全.因为现在硬件每秒可以计算数十亿个散列.这意味着
可以轻松破解每个密码.
    现在鼓励使用自适应的单向函数来保存密码.验证密码时通过故意占用资源(如CPU,内存,等).自适应单向
函数允许配置"工作系数",可以随着硬件发展而增长.推荐工作系数配置大概1秒校验1个密码.这种权衡让攻击
者破解密码变的困难,而带来的成本并不高.Spring Security已经开始试图为"工作系统"提供一个好的开始,
但还是鼓励用户定义自己的工作系数,因为不同系统性能会有很大差距.例如自适应单向函数包含bcrypt,
PBKDF2,scrypt,和argon2.
    由于自适应单向函数是资源密集型,每次验证用户密码会显著降低应用性能.Spring Security或其它任
何库都无法加速,因为就是通过资源密集型来保证安全.所以鼓励将长期凭证(如用户密码)交换为短期凭证(如
,会话,OAuth Token,等).短期凭证可以快速验证而不会带来性能损耗.
---------------------------------------------------------------------------------------
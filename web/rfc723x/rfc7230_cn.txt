2016-06 发布RFC 723X
	RFC7230:HTTP/1.1,章1:消息语法和路由
	RFC7231:HTTP/1.1,章2:语义和内容
	RFC7232:HTTP/1.1,章4:条件请求
	RFC7233:HTTP/1.1,章5:范围请求
	RFC7234:HTTP/1.1,章6:缓存
	RFC7235:HTTP/1.1,章7:认证
	RFC7236:初始HTTP身份验证注册
	RFC7237:初始方法注册
	RFC7238:HTTP状态码308(永重定向)
	RFC7239:转发HTTP扩展
	RFC7240:首选HTTP头

互联网工程工作组	R.Fielding, Ed.
请求意见稿:7230	Adobe
废弃: 2145, 2616	J.Reschke, Ed.
更新: 2817, 2818	greenbytes
类别:标准路线	June 2014
国际标准刊号: 2070-1721

	超文本传输协议(HTTP/1.1): 消息语法和路由

摘要
	超文本传输协议(HTTP)是一种为分布,互联,超文本信息系统开发的无状态应用层协议.
	本章概述HTTP体系结构和相关术语,解释定义"http"和"https"统一资源标识符(URI)方
	案,HTTP/1.1消息语法和分析需求,描述相关安全实施.

关于下段备忘录
	这是一个互联网标准跟踪文档.
	文档由互联网工程工作组(IETF)出产.它代表了IETF的共识.它接受了公众评论并由互联
	网工程指导小组(IESG)核准出发.更多信息参见互联网标准RFC5741第2节.

	有关文档当前状态,勘误表获取,或提供反馈请查看
	http://www.rfc-editor.org/info/rfc7230.

版权声明
	版权(c)2014 IETF 确认为文档记录着.版权所有者.
	本文档是BCP78项目并IETF法律相关IETF文档
	(http://trustee.ietf.org/license-info)生效日期为文档出版日期.请仔细审阅这些
	文件,描述了你对文档拥有的权限和限制.从文档中提取的代码组件必须包含简化的BSD
	许可证文本,如第4.e节所述信托的法律规定,并如简化许可证描述不提供没有担保.

	文档可能包含一些从IETF文档或者IETF贡献发布或2008年11月10日之前公开发布的材
	料.这些材料的版权控制人可能没有授权IETF修改权限在IETF标准过程之外.在没有获
	得适当许可下,在IETF标准过程之外本文档不可能修改,不可能创建衍生品,除重新排版
	发布或者翻译成英语之外的语言的时候.

目录
	1.介绍
		1.1.需要符号
		1.2.语法符号
	2.结构
		2.1.客户端/服务端信息传递
		2.2.实现多样性
		2.3.调节
		2.4.缓存
		2.5.一致性和错误处理
		2.6.协议多版本
		2.7.统一资源标识
			2.7.1.http URI体系
			2.7.2.https URI体系
			2.7.3.http和https URI 归一和正常化
	3.消息格式
		3.1.起点
			3.1.1.请求
			3.1.2.状态
		3.2.头字段
			3.2.1.字段扩展
			3.2.2.字段顺序
			3.2.3.空白
			3.2.4.字段解析
			4.2.5.字段限制
			4.2.6.字段值组成
		3.3.消息体
			3.3.1.传输编码
			3.3.2.内容长度
			3.3.3.消息体长度
		3.4.处理不完整消息
		3.5.消息分析健壮性
	4.传输编码
		4.1.分块传输编码
			4.1.1.块扩展
			4.1.2.分块挂载区
			4.1.3.解码块
		4.2.压缩编码
			4.2.1.压缩编码
			4.2.2.紧缩编码
			4.2.3.Gzip编码
		4.3.TE
		4.4.挂载
	5.消息路由
		5.1.确定目标资源
		5.2.连接到达
		5.3.请求目标
			5.3.1.原格式
			5.3.2.绝对格式
			5.3.3.授权格式
			5.3.4.星号格式
		5.4.主机
		5.5.有效请求URI
		5.6.将一个响应关联到一个请求
		5.7.消息转发
			5.7.1.通过
			5.7.2.交换
	6.连接管理
		6.1.链接
		6.2.建立
		6.3.维持
			6.3.1.重试请求
			6.3.2.管道
		6.4.并发
		6.5.失败和超时
		6.6.销毁
		6.7.升级
	7.ABNF扩展列表: #规则
	8.IANA考虑事项
		8.1.头域注册
		8.2.URI方案注册
		8.3.互联网媒体类型注册
			8.3.1.互联网媒体类型 message/http
			8.3.2.互联网媒体类型 application/http
		8.4.传输编码注册
			8.4.1.程序
			8.4.2.注册
		8.5.内容编码注册
		8.6.升级标志注册
			8.6.1.程序
			8.6.2.升级标志注册
	9.安全事项
		9.1.建立授权
		9.2.中间风险
		9.3.通过协议元素长度攻击
		9.4.响应分解
		9.5.请求盗传
		9.6.消息完整性
		9.7.消息机密性
		9.8.服务器日志隐私
	10.致谢
	11.参考
		11.1.规范参考
		11.2.资料参考
	附录A.HTTP历史版本
		A.1.从HTTP/1.0到现在的变更
			A.1.1.多主机WEB服务
			A.1.2.持久链接
			A.1.3.传输编码导论
		A.2.从RFC2616到现在的变更
	附录B.ABNF集
	索引

1.介绍
	超文本传输协议(HTTP)是一个无状态应用层请求/应答协议,使用可扩展予以和自描述性
	消息,用于灵活地基于网络超文本信息系统.本文档是HTTP/1.1系列规范文档的第一部:
	1.消息语法和路由(本文)
	2.语义和内容[https://tools.ietf.org/html/rfc7231]
	3.请求条件[https://tools.ietf.org/html/rfc7232]
	4.请求范围[https://tools.ietf.org/html/rfc7233]
	5.缓存[https://tools.ietf.org/html/rfc7234]
	6.认证[https://tools.ietf.org/html/rfc7235]
	本规范HTTP/1.1废弃了RFC2616和RFC2145.同时升级了连接的使用来建立通道,之前定义
	在RFC2817,并定义了"https"URI方案,该方案当时在RFC2818中非正式描述.

	HTTP是信息系统的通用协议.设计目标是隐藏服务器如何实现在不依赖于提供资源类型
	的情况下,向客户端提供统一的接口.同样,服务器不需要知道每个客户端的目的:
	一个HTTP请求可以被认为是隔离得,而不是与特定的客户端类型相关或者与应用的预定
	步骤有关系.结果是协议可以有效的应用在不同的环境中,并且各自实现可以随时间独
	立发展.

	HTTP也被设计用于中介协议,用于转换与非HTTP信息系统的通信.HTTP代理和网关能够提
	供访问可供替换的信息服务,通过将它们不同的协议转换为超文本格式.这些在客户端同
	样可以被看到和操作如同服务端.

	这样一个灵活的协议结果是协议不能根据接口后面发生的情况而定义.相反,我们仅限于
	定义语法和通信,接收到通信意图,和收件的预期行为.如果通信时孤立的,成功的行为应
	该在服务器提供的接口变化中被反应出来.然而,自从多客户端可能并行执行并可能交叉
	目标,我们不能要求这种改变是可观察的在超过单一响应的范围.

	本文描述HTTP使用和引用的结构元素,定义"http"和"https"URI设计方案,描述跨网络操
	作和连接管理,定义HTTP消息框架,转发要求.我们目标是定义所有HTTP消息处理需要的
	机制,这些不依赖于消息语义,从而定义消息分析器和消息转发中介的整套需求.

1.1.需要标识符
	关键词"MUST","MUST NOT","REQUIRED","SHALL","SHALL OT","SHOULD","SHOULD NOT",
	"RECOMMENDED","MAY",and "OPTIONAL" 本文依照
	RFC2119[https://tools.ietf.org/html/rfc2119]描述使用.
	关于错误处理的一致性和注意事项定义在段落2.5
	[https://tools.ietf.org/html/rfc7230#section-2.5]

1.2.语法标识符
	规范使用增强版巴克斯范式(ABNF)符号
	[RFC5234https://tools.ietf.org/html/rfc5234],使用列表扩展符,定义在第7章,
    使用'#'操作紧凑定义逗号分隔的列表(类似'*'运算符表示重复).附录B列出了所有对
    ABNF扩展的列表操作语法.

	以下核心规则已经在参考中列出,例如定义在[RFC5234],附录B.1:ALPHA(字母),
	CR(回车), CRLF(回行), CTL(控制),DIGIT(十进制数字0-9),DQUOTE(双引号),
	HEXDIG(十六进制0-9/A-F/a-f),HTAB(水平制表符), LF(换行),OCTET(八字节序列数据),
	SP(空行),VCHAR(可见字符[https://tools.ietf.org/html/rfc7230#ref-USASCII]).
	惯例,ABNF前缀"obs-"表示"obsolete"过时的语法,因为一些历史原因会出现.


2.结构
	HTTP是为了全球互联网体系结构而创建,并随着时间发展,支持全球超文本信息系统的扩
	展需求.很多结构反应在用于定义HTTP的术语和语法的生成.

2.1.客户端/服务端消息发送
	Http是一种无状态 请求/应答 协议,通过可靠通信或会话层交换消息.HTTP"client"客
	户端是同服务器建立连接的一个程序,目的是发送一个或多个HTTP请求.HTTP"server"服
	务器是接受请求并回复响应.

	"client"客户端和"server"服务端仅指程序所扮演的特定角色.同样的程序可能有些连
	接扮演客户端,有些者扮演服务."user agent"用户代理指的是任何一种发起请求的客户
	端程序,包括(不限于)浏览器,爬虫(基于网络机器人),命令行工具,自定义应用,和移动
	端APP."origin server"源服务器指的是能为目标资源生成响应的程序."sender"发件人
	和"recipient"收件人指的是任何分别实现发送和接收消息者.

	HTTP使用统一资源标识符(URI)指明目标资源,与资源间的关系.消息以一种格式传递,类
	似于互联网邮件和多用户互联网邮件扩展(MIME).

	大多数情HTTP通信由通过URI检索一些资源请求.最简单的情况,可能是通过单个用户代理
	与服务端间的双向连接完成.

	客户端向服务器发送请求,从包含请求方法的请求行开始,URI,协议版本,随后头部域包含
	请求修饰符,客户端信息,元数据,一个空行表示头部的结尾,最后是信息体包含承载的信息.

	服务器向客户端的响应,通过发送一个或者多个HTTP响应消息,从开始状态行,包含协议版
	本,成功或失败编码,因由解释,很有可能在头部域后包含有服务器信息,资源元数据,表示
	元数据,最后空行表示头部结尾,最后消息体包含承载数据.

	一次连接可能使用多次请求/响应交换.
	以下例子说明了一个典型的GET请求消息交换过程.
	URI:"http://www.example.com/hello.txt":
	Client request:
	GET /hello.text HTTP/1.1
	User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
	Host: www.example.com
	Accept-Language: en, mi

	Server response:
	HTTP/1.1 200 OK
	Date: Mon, 27 Jul 2009 12:28:53 GMT
	Server: Apache
	Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
	ETag: "34aa387-d-1568eb00"
	Accept-Ranges: bytes
	Content-Length: 51
	Vary: Accept-Encoding
	Content-Type: text/plain

	Hello World! My payload includes a trailing CRLF.

2.2.实现多样性
	在考略设计HTTP的时候,容易落入一个陷阱就是以为所有用户代理都是通用浏览器并且
	所有源服务器都是大的公共网站.事实并非如此.通常HTTP用户客户端包括家庭电器,立
	体音响,音阶,固件升级脚本,命令行程序,移动APP,各种通信设备.同样,HTTP源服务包含
	家庭自动化设备,可配置网络组建,办公设备,自动化机器人,新闻订阅,交通摄像头,广告
	选择器,视频交付平台.

	"user agent"用户代理并不意味着是人为直接交互的软件代理.很多情况下,用户代理是
	安装/配置运行在后台,保存结果待后续查看.例如爬虫,是一个典型的后台用户代理,从
	一个URI开始抓取一个网站的超文本映像.

	HTTP的多样性实现意味着并非所有用户代理可以向用户提供交互式建议,或提供足够的安
	全隐私警告.在少数情况下本规范需要向用户报告错误,这类报告如果只是在控制台或日
	志出现是可以接受的.同样,自动操作在执行前需要用户确认,可能通过配置选择,运行参
	数,或避免不安全操作;确认操作不意味着任何特定用户正常处理的接口或中断,如果用户
	已经做出选择.

2.3.中间层
	HTTP允许通过连接链使用中间层满足请求.通常有三种形式的中间层:代理,网关,和隧道.
	某些情况下,但中间层可以充当一个源服务,代理,网关,或隧道,根据每个请求的性质切换
	行为.

	UA=========A=========B=========C=========O
	上图展示了三个中间层(A,B,C)在客户端和源服务.请求或应答消息会通过4段链接.一些
	HTTP通信选项可能只用于临近节点,或终结点,或整个链上所有节点.尽管图表上显示的是
	线性的,实际上每个节点可能执行多种通信.例如,B节点可能从很多客户端接收请求,并转
	发请求给C,同时处理A的请求.同样的,请求可能被发往不同的路径链接,通常基于负载均
	衡配置动态调整.

	"upstream"上游和"downstream"下游两个术语表现了消息流向:所有消息流是从上游到下
	游."inbound"入站和出站"outbound"两个术语表现请求路由方向:入站表示走向源服务器,
	出站表示走向用户代理端.

	"proxy"代理是消息转发代理,由客户端选择,常通过本地配置规则,为一些绝对URI类型接
	收请求,并尝试通过HTTP接口转换满足请求.一些转换非常小,例如为"http"URIs请求做代
	理,鉴于另一些请求可能转换自不同的应用层协议.为了安全/注释服务或共享缓存的目的,
	代理者常用于HTTP分组请求,通过一个共同的中介.一些代理被设计应用于特定消息或负
	载,当这些消息被转发的时候.

	"gateway"网管("reverse proxy"反向代理)为出站链接扮演源服务器,但是转换收到的请
	求并转发至另一个服务器入站.关网常用于封装信息服务,通过加速缓存提高服务器性能,
	启用分区或负载均衡多台机器上的服务.

	适用于源服务器的所有HTTP要求,同样适用于网关的出站通信要求.网关需要与使用任何协
	议的入站服务器通信,包括私有的超出HTTP本规范的协议.然而,一个HTTP对HTTP网关期望
	与第三方HTTP服务器交互,应符合用户代理对网关入站链接需求.

	"tunnel"隧道是两个链接的盲继电器,不会改变消息.一旦启动,隧道不被认为是HTTP通信的
	参与方,尽管隧道可能是由HTTP请求启动.当中继链接

    两端关闭时隧道也就停止.隧道习惯用于通过中介扩展虚拟链接,类似传输层安全协议用于通
    过共享防火墙代理建立机密通信.

	以上这些只是被作为扮演HTTP通信中介.还有些中介在网络协议更底层,在发送者不知情或无
	授权情况下过滤或重定向HTTP流.网络中介是无法区分是否来自一个中间人攻击,经常引入安
	全缺陷或违反HTTP语义的操作问题.

	例如,一个"interception proxy"拦截代理(也被称为"transparent proxy"透明代理或
	"captive portal"捕获门户)不同于HTTP代理,因为它并未被客户端所选择.相反,拦截代理过
	滤和重定向传出TCP80端口数据包(偶尔还有其它端口通信).拦截代理常见于公共网络访问点,
	作为一种强制手段允许用户订阅互联网,在公司防火墙实施网络使用策略.

	HTTP被定义为无状态协议,意味着每个请求消息是独立能被解读.很多实现有赖于HTTP的无状
	态,复用代理链接或多服务动态负载均衡.因此,一个服务绝对不能假设两个请求来自同一个用
	户代理的同一个连接,除非连接是固定的来自于这个代理.一些非标准HTTP扩展违反这一要求,
	导致安全性和互操作问题.

2.4.缓存
	"cache"缓存是本地存储之前的应答消息,并且子系统控制其消息存储,检索,和清除.缓存存储
	可以被缓存的应答,以提高响应速度并降低网络带宽的消耗.任何客户端或服务器都可能使用
	缓存,但当服务作为隧道时是不能使用缓存.

	使用缓存带来的影响就是请求/响应链变得更短,当链上一个参与者缓存了一个请求响应.下
	图说明B缓存了一个请求的响应.
	UA===========A=========B-------------C---------------O
	响应可缓存行是指允许存储响应的消息,用于后续的请求应答.即使响应可以被缓存,还有可能
	还有其它的限制对客户端或服务器上,对一些特殊的请求.HTTP对缓存的行为和可缓存性定义在
	RFC7234第二章.

	有各种各样体系结构和配置的缓存,部署于互联网和大型网络中.包括跨洋的国家级的代理缓存,
	广播和多播缓存,为离线或高延迟环境使用的预取缓存档案,等等.

2.5.一致性和错误处理
	规范对HTTP通信的参与则要求是一致的.因此,应用于发送者,接收者,客户端,服务端,用户代理,
	中介,源服务器,代理,网关,或缓存.取决于那些行为受到约束.其它对实现的要求,资源拥有着,
	和协议元素注册当它们超出了单一通信范围.

	动词"generate"生成替代"send"发送用来区分创建协议元素和仅仅只将元素转发到下游.
	一个实现如果符合所有HTTP中角色相关需求就被认为是一致的.

	一致性包括协议的语法和语义.发送者不能生成协议元素意思是发送者知道是错误的.发送者
	不能生成协元素不符合定义语法.消息发送者必须不生成协议元素或替代协议,只有允许由其
	它角色参与生成.

	当解析接收到的协议元素时,接收者必须能够解析任何长度的任意值,符合接收者语法定义.
	注意,虽然,一些接收协议元素可能无法解析.例如,一个中介转发一个消息,可能需要解析头
	域为通用的字段名和字段值组件,但不会进一步解析字段值.

	由于长度取决于部署上下文和实现,适合差异很大,所以HTTP没有限定很多协议元素的长度.
	因此,发送方和接收者互通依赖于分享期望的合理协议元素长度.此外,什么是通常理解的合
	理长度在过去的二十年发生了变化,预计未来也会继续变化.

	至少,接收者必须能够解析和处理协议元素长度至少其它协议元素消息是值得长度.例如,
	一个源服务端发布了一个非常长的URI,指向自己的资源,需要能够解析和处理相同内容,
	当自己作为请求目标接收请求时.

	接收者必须安装规范定义的语义解释收到的协议元素,除非接收者确定发送者错误实现了
	语义.例如,一个源服务器可能会忽略收到Accept-Encoding的内容,如果检查User_Agent
	表示特定实现某些内容编码失败.

	除非另外指出,接收者可能尝试从一个无效构造恢复有用的协议元素.HTTP没有定义特定的
	错误处理机制,除非直接对安全产生影响,由于不同应用协议需要不同的错误处理策略.
	例如,浏览器可能期望当头部域无法依照范式解析时能够透明修复,鉴于系统控制客户端可
	能考虑任何形式错误恢复危险.

2.6.协议版本
	HTTP使用"<major>.<minor>"大小版本方案表示版本.本规范版本是"1.1".协议版本完整表
	示发送者复合相应的HTTP规范.

	HTTP消息的版本是由消息第一行"HTTP-version"值域表示.HTTP-version是大小写敏感.
	HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
	HTTP-name     = %x48.54.54.50 ; "HTTP", case-sensitive
	版本号有两个十进制数表示,用"."分隔(句号或小数点).第一个数字(主版本)表示HTTP消息
	语法,第二位(小版本)表示的是最高此版本在主版本内,发送者一致并能够理解在未来通信
	时.次要版本公布发送者通信能力即使发送者只是用向后兼容的子协议,从而让收件人知道
	使用更高级的功能来响应在将来请求中.

	当一个HTTP/1.1消息被发往一个HTTP/1.0接收者或一个接收者版本未知,HTTP/1.1消息可以
	被构建成可以被HTTP/1.0解释在所有新特性被忽略的情况下.发送者只使用兼容特性直到接
	收者版本被确定,通过配置或接收消息,接收者支持HTTP/1.1.

	头部域的解释不会修改在次版本以及主版本间,虽然接收者在缺少该值域时默认行为可以
	修改.除非另有规定,头部值域定义在HTTP/1.1被定义在所有HTTP/1.x版本中.特别的,
	Host和Connection域应该被所有HTTP/1.x实现无论是否宣布与HTTP/1.1一致.

	新的头部域可以在不变更协议版本时使用,如果它们语义允许它们被安全的忽略,当客户定
	不认识它们的情况下.头部域扩展性在3.2.1部说明.

	处理HTTP信息的中介必须发送它们自己的HTTP-version在转发消息中.换种说法,它们不
	允许盲目的转发消息首行,在不确定中介,发送者,接收者的HTTP版本是否一致的情况下.
	转发HTTP消息不重写版本可能会导致通信错误,当下游接收者使用信息发送者版本决定将来
	使用什么安全的特性与发送者同行.

	客户端请求的版本应当是本身支持的最高版本,并且主版本不能高于服务端提供的主版本,
	如此,客户端不能发送一个不一致的版本.

	客户端可能会发送一个低版本的请求,在它知道服务端错误处理HTTP规范,但只能在客户端
	至少尝试一个正常请求,并通过返回码或头部域发现服务端不能正确处理高版本的请求.

	服务端应该发送应答本版应该是自己支持的最高本版,主版本小于或等于收到的请求版本.
	服务端不能发送不一致的版本.服务器可以发送一个505来拒绝客户端的协议主版本.

	服务端可能发送HTTP/1.0应答,在确认得知客户端未能正确处理规范的情况下,例如当
	客户端错误的解析版本号或中介盲目的转发自身不支持的协议版本.协议降级不应当被执行
	当被客户端属性触发,例如当一个或多个请求域唯一匹配已知错误的客户端发送值.

	HTTP设计版本的意图是主版本只有在消息语法不兼容的情况下升级,只版本是在语义增加
	影响或功能能力扩展时升级.然而,次版本在RFC2068与RFC2616间升级,本次修订特别避免
	对协议进行任何此类更改.

	当接收者收到具有主版本号的消息一致,但是次版本号高于自己的实现,接收者应当使用
	自己支持的最高次版本协议来处理消息.接收者可以假设带有较高此版本的消息,发送给
	接收的,尚未表示支持更高版本,是足够向后兼容,可由任何实现相同版本.

2.7.统一资源标识符
	Uniform Resource Identifiers(URIs)[RFC3986]使用HTTP作为识别资源的手段.URI引用
	用于目标请求,表示重定向,定义关系.

	"URI-reference","absolute-RUI","relative-part","scheme","authority","prot",
	"host","path-abempty","segment","query","fragment"都次采用URI通用语法的定义.绝
	对路径定义协议元素包含非空路径组成.(这个规则不同于轻量临时路径规则,临时路径允许
	空路径引用,而绝对路径不允许路径由"//"开始.) "partial-URI"部分标识规则定义协议元
	素能包含相对URI但不是一个片段组件.

	URI-reference = <URI-reference, see [RFC3986], Section 4.1>
	absolute-URI  = <absolute-URI, see [RFC3986], Section 4.3>
	relative-part = <relative-part, see [RFC3986], Section 4.2>
	scheme        = <scheme, see [RFC3986], Section 3.1>
	authority     = <authority, see [RFC3986], Section 3.2>
	uri-host      = <host, see [RFC3986], Section 3.2.2>
	port          = <port, see [RFC3986], Section 3.2.3>
	path-abempty  = <path-abempty, see [RFC3986], Section 3.3>
	segment       = <segment, see [RFC3986], Section 3.3>
	query         = <query, see [RFC3986], Section 3.4>
	fragment      = <fragment, see [RFC3986], Section 3.5>
	absolute-path = 1*( "/" segment )
	partial-URI   = relative-part [ "?" query ]

	HTTP每个协议元素,允许URI引用,使用巴斯克范式表示.元素允许任何形式的引用,只有一个
	URI绝对形式,仅路径和可选查询组建,或者一些以上两者组合.除非另有说明,URI引用是相对
	有效的请求URI.

2.7.1HTTP URI 方案
	"http"方案定义目的是构建标识符,依据协会的命名空间分层,受潜在的服务器管理,监听
	给定的端口.

	http-URI = "http:""//" authority path-abempty [ "?" query ][ "#" fragment ]

	源服务器http URI由授权部分,包含主机标识和TCP端口.分层路径部分和可选查询部分作
	为潜在服务器资源的命名空间标识.可选片段部分允许间接标识第二层资源,独立于URI方案.
	发送者绝对不能产生一个空主机标识的http URI.接收者必须拒绝处理作为无效.

	如果主机标识是由IP地址表示,源服务器是在该IP地址下监听端口.如果主机由域名表示,
	注册名称是一个使用名称服务器解析间接表示,如DNS,用于找到源服务器地址.如果端口
	部分是空的或未提供,默认在TCP80口.

	注意存在的URI并不意味着一直有HTTP服务器这里对应的地址端口监听提供服务。任何人
	都可以创造一个 URI。主权确定了谁有权利做出权威性的应答请求，确定标识的资源。
	委托性质的注册名称和IP地址创建一个组合命名空间，基于控制表明主机和端口，无论
	HTTP服务是否存在.有关建立授权参见9.1部安全注意事项.

	当一个HTTP URI在语境中用于访问所表示的资源，客户端可能尝试访问，通过解析主机为
	IP地址，建立TCP连接，并发送HTTP请求，消息包含URI的服务标识.如果服务响应非临时
	的HTTP应答请求,就如章节6描述,那 么这个应答就被认为是权威的回答客户端的请求.

	尽管如此HTTP是独立于传输协议,由于命名委派过程依赖与TCP建立权威,所以HTTP方案特定
	基于TCP服务. 基于其它底层连接协议的HTTP服务大概会使用不一样的URI标识方案，就如
	HTTPS方案用于资源需要端到安全连接。另一些协议可能也用于提供访问http标识资源--唯
	有权威接口特定于TCP。

	用于权威的URI普通语法同样也包含已弃用的用户信息子组件(RFC3986章节3.2.1)，包含了
	用户身份验证信息.一些实现利用用户信息部分,内部配置身份验证信息,例如在命令调用
	选项,配置文件,或书签列表,即使这些用法可能暴露用户表示或密码.发送者不可生成用户
	信息子部分(及其@分隔符)当URI引用作为消息一部分,作为请求目标或头部值域.在使用从
	不信任源接收到的http URI引用前,接受者应当解析用户信息并将它视为错误;这个很可能
	用来遮掩权威,为了网络钓鱼攻击.

2.7.2. https URI方案
	https URI方案定义目的是构建标识符，依照它们联系等级命名空间,由潜在服务器监听的
	TCP地址和TLS安全连接相关构成.

	所有http方案的需求同样的也是https方案也需要,除默认端口是443之外,同时用户代理必须
	保证连接源服务器安全,通过使用强加密,端到端,发送第一个HTTP请求前.

	http-URI = "https:" "//" authority path-abempty [ "?" query ] [ "#" fragment]
	注意https方案同时依赖于TLS和TCP建立权威.资源发布通过https方案,没有与http共享标识,
	即使他们资源标识表示同样的地址(同样的主机监听端口).被认为是不同的命名空间和不同
	的源服务.然而,扩展http被定义应用于整个主机域,例如Cookie协议[RFC6265],可允许匹配
	的组的主机域内一台服务设置信息影响另一台服务的通信.

	处理权威访问的https标识资源定义在[RFC2818].

2.7.3. http和https URI标准化和比较
	由于http和https都符合URI的通用语法,URIs被标准化和比较依据算法定义在[RFC3986]第6章,
	使用默认描述了以上每个方案.

	如果端口是方案的默认值,一般会省略端口部分.当请求目标是可选时不用绝对格式,空路径
	部分等于绝对路径"/",所以通常的形式是使用一个"/".主机部分是大小写不敏感,通常使用
	小写;所有其它部分都是大小写敏感.其它字符比那些保留着的等于它们的百分比编码:通常
	不会进行编码(阅[RFC3986]第2.1和2.2章节).

	如一下三个RUI是相等的:
	http://example.com:80/~smith/home.html
	http://EXAMPLE.com/%7Esmith/home.html
	http://EXAMPLE.com:/%7esmith/home.html

3.消息格式
	所有http/1.1消息由起始行随后一个序列8位字节组成,格式类似于互联网消息格式[RFC5322]:
	零或更多头域(统称为头或头部),空行表示头部结束,后随可选的消息体.

	HTTP-message = start-line *( header-field CRLF) CRLF [ message-body ]

	通常程序解析HTTP消息是读取开始行转为结构,每个头值域转为哈希表,值域名称为键,直到
	空行结束,最后解析消息体数据.如果消息体表明,它被作为流读取,直到读取8位字节数等于
	消息体长度或者连接被关闭.

	接收者必须解析消息为一个序列的8位字节,编码为US-ASCII超集.消息作为Unicode字符集
	流解析,不需要考虑特定编码,由于字符处理库处理无效的包含八位字节字节LF(%x0A)的多位
	字符序列不同方式造成安全漏洞.基于字符串的解析器只能在协议元素中安全地使用,从消息
	中提取元素.比如消息分析后的头字段值已经描述了单字段.

	HTTP消息可以被作为一个流用于增强处理或转发下有.不管怎么说,接收则不能依赖于部分
	信息的增量传递,由于为了提高网络效率/安全检查/信息转换目的,一些实现了缓冲或延迟转发.

	发送者不在在首行与头部域第一个值之间使用空白.如果接收者收到此类消息必须将其作为
	无效信息拒绝处理.或不做处理的使用每行前的空白.(即,忽略整行,连同后面任何前面带空
	白行,知道收到适当形式的标题行或头部域结束.)

	请求中的这类空白可能是尝试欺骗服务忽略那些值域,或之后处理作为一个新的请求,其中
	任何一种都可能导致安全漏洞,如果实现请求链解释同样信息.同样,存在响应的空白,可能
	会被客户端忽略或使其停止处理.

3.1.起始行
	HTTP消息可以是从客户端来的请求,或者是来自服务的应答.语法上,两者只是在起始行有
	区别,一个由请求行开始一个有状态行开始,以及算法中确定消息正文长度(章节3.3).理论
	上,客户端可能会接收到请求,服务可能接收到应答,可以用不同起始行来区别,但是,在实
	践中,服务只是期望得到请求,客户端总是期望应答.

	start-line = request-line / status-line

3.1.1.请求行
	请求行始于方法标记,紧随单空格,请求目标,单空格,协议版本,回车回行结束.
	request-line = method SP request-target SP HTTP-version CRLF
	GET http://www.163.com HTTP/1.1

	请求方法表明在目标资源执行的方法.方法名是大小写敏感.
	请求方法定义在RFC7231第四章,以及相关HTP方法注册表和定义新方法注意事项.
	请求目标标识目标资源,定义在5.3节.

	接收通常使用空白符拆分组成部分来解析请求行(3.5节),因为三个组成部分的内容都不允
	许存在空白符.不幸的是,一些代理无法正确编码,排除超文本中的空白,导致那些不允许的
	字符被发送到请求目标.

	接收到无效的请求行时,应当返回400(错误请求)或301(永久移除)重定向一个正确编码的请
	求地址.接收者不应该尝试自动修正然后不进行重定向处理,因为这些无效的请求可能是故意
	制造出来用来绕过安全过滤器.

	HTTP没有对请求行做长度限制,服务如果收到超过任意方法长度应当返回501未能处理状态.
	如果收到的请求目标超过任意目标,必须返回414URI过长.见[RFC7231]6.5.12章节.

    实践中能找到各种临时的对请求长度限制.这里推荐一个最小的8000字节限制.

3.1.2.状态行
    应答的第一行是状态行,由协议版本,一个空格,状态码,另一个空格,一个文本用于解释
    状态码可能是空的,最后回行结束.
    status-line = HTTP-version SP status-code SP reason-phrase CRLF
    HTTP/1.1 200 OK

    状态码为3位整数,表示服务对请求处理的结果状态.剩下是对状态语义的解释.定义在[RFC2731]第6章.
    有关状态定义,包含等级状态,本规则定义状态码,考虑到新的状态码,和IANA注册.
    status-code = 3DIGIT

    因由解释元素的存在,主要目的是提供对数字状态码进行文字表述,最多出于对早期互联网应用协议的
    尊重,更常用于交互式文本客户端.客户端应当忽略解释短语.
    reason-phrase = *(HTAB/SP/VCHAR/obs-text)

3.2.首部值域
    首部的值域由非大小写敏感的名称加(":"),可选的前导空白,再加值,可选的尾随空白.
    field-name     = token
    field-value    = *( field-content / obs-fold )
    field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
    field-vchar    = VCHAR / obs-text

    obs-fold       = CRLF 1*( SP / HTAB )
        ; obsolete line folding
        ; see Section 3.2.4

    字段名标记相应字段值,就像首部字段定义的语义.例如,日期首部字段定义在[RFC7231]7.1.1.2,
    包含了最初时间戳作为信息的出现.

3.2.1.字段可扩展行
    首部字段是完全可扩展:不存在限制,采用新的字段名,每个定义新的予以,也不限定消息中
    使用首部字段的数量.现有字段在规范的每个部分都有定义,在其他另一些规范超出本文档的集合.

    一些情况下需要定义新的首部字段,它们可以被接收者理解,可能覆盖或更好解释之前的字段,
    定义先决条件在请求评估,或提炼应答的意思.

    代理必须转发不认识的首部字段.出发这些字典属于链接首部字段(6.1章节)或代理特别
    配置阻止,或除此之外的转换.另外接受者应当忽略不认识的头部字段.这些要求允许HTTP
    功能增加情况下,而无需已部署的中介升级.

    所有定义的首部字段应当用IANA注册,如[RFC7231]8.3部分.

3.2.2.字段顺序
    不通字段名在首部的顺序是不重要的.然而,发送首部字段让控制数据放在第一是较好的
    实践,就像请求中的主机地址和应答中的日期,这样实现可以更早判断是否继续处理消息.
    服务不能应用请求于目标资源知道完整的接收请求首部,因为后面的字段可能包含条件,
    授权认证,或者一些重复的字段故意误导可能会影响请求的处理.

    发送者不能产生多个相同名称的首部字段,除非字段被定义用逗号隔开的列表值,或一些
    被熟知的例外.

    接收者可能会合并首部相同名称的字段在一个"filed-name: filed-value"对里,而不修改
    消息的语义,用逗号顺序拼接每个子域.首部同字段名的顺序对解析组合值由重要的意义.
    代理转发时不可修改字段的顺序.

    注意:
    实践中,"Set-Cookie"字段([RFC6265])常多次出现在应答消息中,并不会使用列表语法,
    违反上面对多个同名字段的要求.因为它们不能够被合并成一个字段,接收者应当把
    "Set-Cookie"作为一个特殊案例进行处理.(见附录 A.2.3或[Kri2001]详细.)

3.2.3.空白
    规范使用了三种规则表示使用行空白:OWS(optional whitespace),RWS(required whitespace)
    ,BWS("bad" whitespace).

    OWS规则被在0或更多行空白字节可能出现.为了协议元素提高可读性使用可选的空白,
    发送者应当使用可选空白如单个SP;除此以外,发送者不应当使用可选空白除了类似需要
    无效空白或不需要的协议元素,在过滤消息期间.

    RWS用于至少需要一个字节行开白来分割字段标志.发送者应该使用RWS如单个SP.

    BWS用于只为历史版本允许的可选空白.发送者在消息中不能使用BWS.接收者必须在
    解读协议元素前,解析这类空白并移除.

    OWS = *(SP/HTAB); optional whitespace
    RWS = 1*(SP/HTAB); required whitespace
    BWS = OWS ; "bad" whitespace

3.2.4.字段解析
    消息使用通用算法解析,依赖于独立的字段名称.字段的值开始并不解析出来,直到下一个
    消息解释阶段.所以本规范不使用ABNF范式定义"Field-Name:Field Value"键值对,就如
    之前版本所作.反而,本规范使用ABNF根据每个注册字段名字而命名,其中定义值有效语法.

    字段名和冒号之间不允许有空白.过去,空白处理差异带来安全漏洞,在请求路由和相应处
    理时.服务必须拒绝接收这类请求,并返回400(Bad Request).代理在转发响应消息时,必须
    先移除这类空白.

    字段值可能缀或后缀空白;单空格前缀能够很好的提高可读性.字段值本身不能包含任何前缀
    或者后缀的空白:提取值时需要排除前后的空白.

    过去,首部字段值可以被延展成多行,通过在每个行前缀至少一个空白或tab.本规范弃用了
    这种折叠,除了消息的媒体类型(8.3.1部分).发送者不能产生包换折叠行的消息.

    服务如果收到此类请求,必须绝句400(Bad Request),回应无法接收折叠行解释会更好,
    或在解析值或转发消息前,将每个折叠行替换一个或多个空格.

    代理或网关收到折叠行时必须抛弃消息并返回502(Bad Gateway),回复无法处理折叠行,
    或在解析或转发前替换折叠行.

    用户端如果收到带有折叠行的应答消息时,必须替换折叠行为空格,再进行解析.

    过去,HTTP允许字段内容包含ISO-8859-1字符集,支持其他字符集只能通过[RFC2047]编码.
    实践中,大多数首部字段值只是US-ASCII字符集的子集.新定义首部字段应当限制值在
    US-ASCII.接收者应当处理其他字节作为不透明数据.

3.2.5.字段限制
    HTTP并未预定首部字段的长度或首部整体长度,如2.5部分.实际中会有各种临时的长度限定,
    常依赖于具体字段的语义.

    服务接收到请求首部字段,或一系列字段,超过处理期望是,必须响应4XX错误状态码.忽略
    此类信息有助于提高服务器的安全(9.5部分).

    客户端在收到超过处理期望长度时,可能丢弃或截断收到首部字段.抛弃的值不会影响消息
    结构和响应语义.

    多数首部值使用通用语法组件(标识,引用字符串,注释)使用空白分隔,或特定分隔符.
    分隔符选自US-ASCII可见字符,不允许使用的标识中有(DQUOTE and "(),/:;<=>?@[\]{}").
    token = 1*tchar
    tchar = = "!" / "#" / "$" / "%" / "&" / "'" / "*"
              / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                / DIGIT / ALPHA
                ; any VCHAR, except delimiters
    字符文本用双引号标记时被解析为一个单独的值.
    quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
    qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
    obs-text       = %x80-FF
    一些HTTP首部字段可以包含注释,使用括号.注释之允许字段包含"comment"作为值得一部分.
    comment        = "(" *( ctext / quoted-pair / comment ) ")"
    ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
    反斜杠("\")被用于单字节引用构成引用字符串和评论结构.接收端处理引用字符串必须
    处理引用对,类似使用反斜杠替换.
    quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )

    发送者不应当在引用字符串中产生引用对,除非内容必须使用引用符使用反斜杠进行转义.
    同样注释中也应当不会有括号,需要时用反斜杠转义.

3.3.消息体
    消息体是HTTP消息内容的有效载荷.消息体和有效载荷是一致的,除非使用了编码传输,
    3.3.1章节描述.

    message-body = *OCTET

    什么时候能使用消息体规则,对于请求和应答是不同的.

    请求中Content-Length或Transfer-Encoding首部字段值标志着消息体的存在.消息体构成
    与方法语义无关,即使方法没有定义任务消息体的使用.

    应答消息体要看正在响应的请求方法和应答状态码(3.1.2).对HEAD方法的响应
    ([RFC7231]4.3.2)不会包含消息体.这个有关响应首部字段
    (Transfer-Encoding, Content-Length,等等..),如果存在,仅表示如果请求的值已获取,
    那他们的值是什么([RFC7231]4.3.1). 2xx(成功)响应CONNECT请求方法([RFC7231]4.3.6)
    切换到隧道模式而不是消息体.所有1xx(信息),204(无内容),和304(无修改)应答都没有消息体.
    所有其它应答都有消息体,即使消息体长度可能是零.

3.3.1.传输编码
    Transfer-Encoding首部字段列出传输编码的名称,应用于承载消息构成消息体.传输编码定义在4.

    Transfer-Encoding = 1*transfer-coding

    Transfer-Encoding 类似于MIME的Content-Transfer-Encoding字段,该协议被设计出来是为了
    能够在7bit传输协议上安全的传输二进制数据([RFC2045],6章).然而,8bit传输协议安全传输
    方面有不同的侧重点.HTTP为例,传输编码主要是为了准确限制动态负载和区分有效荷载编码.
    为了高效安全传输所选资源.

    接收者必须能够解析分块的传输编码(4.1节),由于其在构建消息上扮演关键角色,当负责体大小
    没有预知.发送者不能多次对一个消息提进行分区(不可以对一个已经经过分区的消息进行分区).
    如果任何除分区以为编码被引用在消息体上,发送者必须以分区编码作为最终传输编码,保证消息
    被正确构建.如果任何除分区以外的编码被使用,发送者也必须使用分区编码作为最终获结束消息.
    例如:Transfer-Encoding: gzip, chunked
    以上表明消息体经过了gzip压缩编码,然后使用分区编码格式化消息体.

    不像Content-Encoding([RFC7231]3.1.2.1节),传输编码是消息的一个属性,不是表明,任何传输
    链上的接收者可能解码或添加传输编码应用在消息体上,假设对传输编码字段值进行了相应的
    修改.有关编码参数的其它信息,可以由本规范未被定义的字段提供.

    传输编码可能在请求应答中发送或在304(未修改)中应答([RFC7232]4.1)GET请求,两者都不包含
    消息体,来表示源服务会应用传输编码,当请求是无条件的GET.这种表示不是必需的,因为
    任何接收者都可以移除传输编码在该编码不需要的时候.

    在任何响应状态是1xx(信息)或204(无连接)时,服务定不能发送传输编码字段.还有就是响应
    CONNECT请求的2xx(成功)返回([RFC7231]4.3.6).

    Transfer-Encoding实在HTTP/1.1加入.通常HTTP/1.0不支持传输编码就无法处理编码的信息.
    客户端定不能发送一个包含传输编码的请求.这些信息可能来自用户具体配置或记录上个接收
    到响应的版本.服务定不可发送包含传输编码的响应,除非请求表明自己是HTTP/1.1或更高版本.

    服务如果收到请求消息的传输编码自己无法理解时,应答返回501(未实现).

3.3.2.长度字段Content-Length
    当消息不存在传输编码字段时,Content-Length内容长度字段可以预示内容长度,十进制数字
    以字节为单位,表明潜在荷载体长度.当消息包含荷载提时,内容长度值提供必要结构信息,确定
    消息体的结束位置.当消息不包含荷载体,长度表明可选代表的大小.

    Content-Length = 1*DIGIT

    例如: Content-Length:3495
    发送者定不可在包含有传输编码字段的消息中发送内容长度字段.

    用户代理在请求消息时如果未使用传输编码就应当发送内容长度,并请求方法定义一个表示
    荷载体结束的符号.例如,POST请求一般会内容长度0(表示无传输内容).如果请求内容不包含
    内容体并且方法语义本身无内容体,客户端就不应当发送Content_Length字段.

    服务器对HEAD请求可能会发送一个Content-Length字段([FRC7231]4.3.2章节);服务器不得在
    此类响应中发送Content-Length，除非其字段值等于如果同一请求使用GET方法，则在响应的
    有效内容正文中发送的八位字节的十进制数。

    服务器可以对条件请求响应304(未修改)中发送Content-Length字段([RFC7232]4.1);服务器
    不可在此类相应中发送Content-Length,除非字段值十进制数等于内容已经发送同一个相应的
    内容中长度.

    对于任何状态是1XX(信息)或204(无内容)的响应,服务器定不可发送Content-Length字段.
    对于任何2XX(成功)响应一个链接请求时,也是不能发送Content-Length字段([RFC7231]4.3.6).

    除上述之外,在没有传输编码的情况下,源服务器应当当发送Content-Length字段,在发送完整
    首部前已知荷载的大小.这样使下游接收者能够衡量转发进度,获知消息接收何时完成,可能将
    连接重用于其他请求.

    任何Content-Length字段值大于或等于0都是有效的.由于未预定荷载长度限制,接收者必须预知
    潜在的大数字并能够处理整数溢出错误(Section 9.3).

    如果接收到一个消息,存在多个Content_length字段而值都是一样的,或只有一个长度字段但值
    是一个列相同数的值(例如:"Content-Length: 42, 42"),此时表明上游的信息处理产生了重复
    或合并的长度字段,此时接收者必须将以无效信息拒绝或者重写一个有效的长度信息替代.

    注意:HTTP消息框架使用长度字段与MIME有着明显的不同,仅在"message/external-body"媒体
    类型中使用,并只是一个可选字段.


3.3.3.消息体长度

    消息体长度有以下之一确定(按优先级排序):

    1.任何对HEAD请求的响应,并且是1xx(信息),204(无内容),或304(未修改)状态码总是以首部
    后的第一个空行结束,不管首部是否存在字段,并且这些不能包含消息体.

    2.任何2xx(成功)对CONNECT请求响应,意味着连接在首部标题空行后将立即转为通道.客户端
    必须忽略任何Content-Length或Transfer-Encoding字段.

    3.如果有Transfer-Encoding并且分块传输编码(4.1章)是最终编码,消息体的长度是由读取
    和解码数据块决定,知道传输编码表示数据完成.

    如果响应中有Transfer-Encoding字段,并分块传输编码不是最终编码,消息体的长度由读取连接
    决定直到服务关闭连接.如果Transfer-Encoding存在请求中,并分块传输编码非最终编码,
    消息体长度是无法确定的;服务必须响应400(错误请求)编码并关闭链接.

    如果消息中同时存在Transfer-Encoding和Content-Length,传输编码覆盖内容长度.如此消息
    可能舱室执行请求走私(9.5章)或响应分裂(9.4章),应当处理为错误.发送者必须移除在
    向下转发前移除内容长度字段.

    4.接收的消息没有传输编码,并具有多个内容长度字段值不同,或者只有一个内容长度值错误,
    则消息被认为无效并必须作为不可恢复处理.如果这是个请求消息,服务必须回应400(错误请求)
    状态码并关闭链接.如果这是一个来自代理的响应,代理必须关闭请求,丢弃接收的相应,并发送
    502(错误网关)返回给客户段.如果这是一个来自用户代理的相应,代理必须关闭于服务器的请求
    并丢弃响应.

    5.如果存在一个有效的长度字段并无传输编码字段,数值定义期望的消息字节长度.如果发送者
    关闭链接或者接收超时,在到达表明的接收长度前,接收者必须认为消息是不完整的并关闭链接.

    6.如果这是一个请求的消息,并且不符合以上任何一点,那么消息体长度为零(不存在消息体).

    7.除此以外,是响应消息并且没有消息体长度,那么消息体的长度决定于服务器关闭连接前接收
    到内容的字节长度.

    由于无法区分成功完成的内容,网络中断引起的部分消息,服务应当尽可能的编码或者长度界定.
    关闭界定主要是为了HTTP/1.0先后兼容.

    请求包含消息体却没有标识长度可能会被服务器拒绝411(需要长度).

    除非应用了分块以外的传输编码,如果能预先知道消息体的长度,客户端就应当标明长度,而不是
    分块传输编码,由于一些服务器会返回411(需要长度)编码即使能处理分块传输编码.这是非常
    典型的,这样的服务器通过网关实现,在调用前需要预先知道长度,并且不可能或不愿意在处理前
    缓存整个请求.

    在不清楚服务端是否能处理HTTP/1.1(或更高)版本时,用户代理必须包含长度字段.

    如果最终的响应接收完成,此时仍有其他数据要丢失,用户代理可能丢弃这部分数据,或者尝试
    确定这些数据是不是属于之前的响应消息体,有可能响应消息标识的长度出错了.这种情况客户
    端不可处理,缓存,或者转发这部分多余的数据作为单独的回应,因为这种行为可能会让缓存出
    问题.

3.4.处理不完整的信息

    服务器收到一个不完整的请求,通常由于请求取消或超时,可能在关闭链接前发送一个错误回应.

    客户端收到一个不完整的响应,可能由于过早的链接关闭,或解码时失败,此时必须标志消息不
    完整.缓存需要完整的响应,定义在第3章[RFC7234].

    如果响应在首部信息的中间中断(在接收到空行前),并且状态码可能依赖于首部字段传递玩完整
    的响应意思,客户端不能假设所有意思被传达;客户端很有可能需要重新请求来决定接下来的工作.

    使用分块传输编码的消息体未完整,如果未能接收到零大小表示的终结分块.一个有效长度标识的
    消息未完整是接收到消息体小于标识的长度.当未采用分块传输编码也未标识长度时,仅用链接
    关闭决定,那么只要接收到完整的首部,与接收到消息体的大小无关.

3.5.消息解析的健壮性

    老的HTTP/1.0用户代理实现可能在PSOT请求后发送一个扩展CRLF,为了解决早期应用服务在读取
    无终结符空行消息时失败问题.HTTP/1.1用户代理一定不能在请求前后发送扩展CRLF的消息.
    如果需要行尾符结束请求消息体,必须要将CRLF结束符作为消息体大小的一部分.

    为了健壮性,服务器期望接收到并解析请求行前忽略至少一个空行CRLF.

    虽然开始行的终结符并首部字段是序列的CRLF,接收端可能会把一个LF当作行终结,并忽略任何
    前面的CR.

    虽然请求行和状态行语法上是需要的,并每个元素部分使用SP分割,接收端可能用空白分隔符
    代替CRLF终结符作为边界,把任何空白都作为SP分隔然后忽略任何前缀或后缀的空白;这些空白
    包含一个或更多如下字节:SP,HTAB,VT(%x0B),FF(%x0C),或者只是CR.然而,宽泛的解析可能得到
    一个安全健壮的结果,如果有多个接收者消息,每个都有自己对健壮性独特理解(9.5章).

    当服务器只是监听HTTP请求消息,或处理从开始行出现的请求消息,接收到一序列字节不符合
    HTTP消息语法除上述的情况外,服务器应当回应400(错误请求).


4.传输编码

    传输编码名称意味着应用了传输编码,可以,或可能需要应用在消息体,用来确保网络安全传输.
    这个有别于内容编码,传输编码是消息属性,而不是正在传输的表示属性.

    transfer-coding    = "chunked" ; Section 4.1
                        / "compress" ; Section 4.2.1
                        / "deflate" ; Section 4.2.2
                        / "gzip" ; Section 4.2.3
                        / transfer-extension
    transfer-extension = token *( OWS ";" OWS transfer-parameter )
    参数采用名称或名称=值得键值对形式.
    transfer-parameter = token BWS "=" BWS ( token / quoted-string )

    所有传输编码名称都是大小写不敏感并应该在HTTP传输编码中注册,如8.4章定义.它们用于
    TE(4.3章)和Transfer-Encoding(3.3.1章)首部字段.

4.1.分块传输编码

    分块传输编码包装消息体,目的是为了分块进行序列传输,每块有自己的大小,最后以包含首
    字段的OPTIONAL结尾.分块传输能让位置大小的内容流分量为顺序块传输,能够让发送者保持
    持久链接同时接收者能够知道什么时候接收了完整的消息.
     chunked-body   = *chunk
                      last-chunk
                      trailer-part
                      CRLF

     chunk          = chunk-size [ chunk-ext ] CRLF
                      chunk-data CRLF
     chunk-size     = 1*HEXDIG
     last-chunk     = 1*("0") [ chunk-ext ] CRLF

     chunk-data     = 1*OCTET ; a sequence of chunk-size octets
    chunk-size分块大小使用16进制表示数据块字节大小.分块传输完成是由接收到零大小块表示,
    可能跟随结尾,最终空行结尾.

    接收端必须能够解析和解码分块传输编码.

4.1.1.块扩展

    分块编码允许每块包含0或更多快扩展,紧随其后是chunk-size分块大小,为了提供每块元数据,
    中间消息控制,或随机消息体大小.
     chunk-ext      = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )

     chunk-ext-name = token
     chunk-ext-val  = token / quoted-string
    传输编码特定于每个连接,很可能被接收则删除或记录重复在任何高级应用检查扩展前.因此,
    分块扩展通常限于在HTTP服务使用,如长链接用来端到端安全传输.

    接收者必须忽略未识别的传输扩展.服务应当限制传输扩展的总长度,已于应用长度限制相同,
    另一部份超时,产生4xx(客户端错误)如果总量超出.

4.1.2.分块结尾部分

    结尾部分允许发送者包换附加的字段在结束的分块信息,为了提供元数据可能会动态生成在
    消息体发送之后,如消息的完整性检查,电子签名,或后处理状态.尾字段与首部字段是一样的,
    除了尾字段是在分块末尾发送的.
    trailer-part   = *( header-field CRLF )
    发件人不能生成一个包含消息框架需要的值域的尾部(例如,传输编码和长度),路由(例如,主
    机),请求修改(如,控制和条件[RFC7231]第5章),认证([RFC7235]和[RFC6265]),应答控制数据
    ([RFC7231]第7.1章节),或决定如何处理消息体(如,内容编码,内容类型,内容范围,和尾部).

    当分块消息包含非空的尾部,接收者可能想首部字段一样处理这些字段(除上述禁止的字段).
    接收者必须忽略(或可考虑当成错误)任何禁止在尾部出现的字段,因为处理这些要求在首部
    出现的字段可能会绕过安全过滤.

    除非请求头包含TE指示"尾部",否则可接受,如4.3章节描述,服务不应当生成它认为客户端
    必须需求的尾字段.没有包含"尾部"的TE,服务应当假设尾部字段可能在传输路径上默默被
    删除.如此可允许中介转发中间分块消息给HTTP/1.0接收者而不用缓存整个应答.

4.1.3.解码分块

    解码分块传输编码的伪代码如下:
        length := 0
        read chunk-size, chunk-ext (if any), and CRLF
        while (chunk-size > 0) {
           read chunk-data and CRLF
           append chunk-data to decoded-body
           length := length + chunk-size
           read chunk-size, chunk-ext (if any), and CRLF
        }
        read trailer field
        while (trailer field is not empty) {
           if (trailer field is allowed to be sent in a trailer) {
               append trailer field to existing header fields
           }
           read trailer-field
        }
        Content-Length := length
        Remove "chunked" from Transfer-Encoding
        Remove Trailer from existing header fields

4.2.压缩编码

    用于压缩传输信息.

4.2.1.Compress编码

    压缩编码是一种自适应Lempel-Ziv-Welch编码,来源于UNIX文件压缩程序"compress".
    接收者可以应当把"x-compress"等同于"compress".

4.2.2.Deflate编码

    "deflate"编码是一种"zlib"数据格式[RFC1950]包含"deflate"压缩数据流[RFC1951],
    使用Lempel-Ziv(LZ77)压缩算法和Huffman编码组合.
    注意:一些不符合标准实现在未zlib包装的情况下发送压缩数据.

4.2.3.Gzip编码

    "gzip"编码是一种LZ77加上32位循环冗余校验(CRC),通常由gzip文件压缩程序生成
    [RFC1952].接收者应当将"x-gzip"等同于"gzip"看待.

4.3.TE

    "TE"首部字段请求表明那种传输编码,除了分块,客户端将愿意接受回应,并不管客户端
    是否接受分块传输编码的尾字段.

    TE值域是一列传输编码名称组成,由逗号分隔符分隔,每个都允许可选参数,并或关键词
    "trailers".客户端不可在TE中写分块传输编码名称;分块对HTTP/1.1总是可接受的.
     TE        = #t-codings
     t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS ";" OWS "q=" rank
     rank      = ( "0" [ "." 0*3DIGIT ] )
                / ( "1" [ "." 0*3("0") ] )

    以下例举三个例子:
     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

    关键词"trailers"表示客户端可以在分块传输编码中接收尾字段,如4.1.2章节所定义,代表
    自己或任何下游客户端.对于从中介来的请求,这意味着:所有下游客户端都接受转发应答的
    尾部字段;或,中介将尝试缓存应答,代表下游接收者.注意HTTP/1.1未定义任何关于限制分区
    响应的大小,因此中介要确保缓存整个相应.

    如果可以接收多个传输编码,客户端可以根据不考虑大小写的"q"参数排序优先级(与内容协
    商字段中使用的q值相似,[RFC7231]第5.3.1章节).等级值是介于0至1之间的实数,0.001是最
    低优先级并1是最高优先级;值0表示不可接受.

    如果TE值是空或没有TE字段存在,那么唯一可接受的传输编码是分区编码.没有传输编码的消
    息总是可接受的.

    由于TE头字段仅适用于直接连接,TE发送者必须发送一个"TE"链接可选在首部(6.1章节),防止
    TE字段由不支持的中介转发.

4.4.尾部

    当消息包含通过分区编码的消息体,发送者希望通过尾字段的方式发送元数据,此时发送者应当
    在消息体前生成尾的首字段,表明什么字段会出现在尾部.这样可以是接收者在开始处理消息体
    前就能知道元数据并做好准备,这样做很有用,如果消息是一个流,并接收者希望能即时检查完整
    性.
    Trailer = 1@field-name


5.消息路由

    HTTP请求消息路由取决于每个客户端基于目标资源,客户端配置,和建立或重用入站链接.响应
    路由照样使用已建立的链接链路返回.

5.1.识别目标资源

    HTTP被广泛用于多应用中,从通用计算机到家用.一些情况下,通讯选项被硬编码在客户端配置中.
    然而,大部分HTTP客户端依赖于相同的资源标识机制并配置技术作为通用WEB浏览器.

    用户代理为一些目的发起HTTP通讯.目的组合请求语义,定义在[RFC7231],以及在其之上应用这些
    的目标资源.URI引用(2.7章节)是典型应用标识"目标资源",用户代理能够解析成绝对形式以获得
    目标URI.目标URI排除了引用的组成片段,如果有的话,因为片段是由客户端来处理的([RFC3986]
    3.5章节).

5.2.链接入站

    一旦目标URI确定,客户端需要决定是否需要网络请求来完成目标,如果这样,请求定向到哪里.

    如果客户端有缓存[RFC7234]并能满足请求,那么请求一般会被首先定向到这里.

    如果缓存不能满足请求,通常客户端会根据配置来决定某个代理是否能满足请求.代理配置取决于
    实现,但是通常基于URI前缀匹配,可选择权限匹配,或两者同时配置,代理本身通常由http或https
    URI表示.如果代理合适,客户端通过建立链接来入站.

    如果没有合适的代理,典型的客户端会调用一个常规处理,通常特定于目标URI方案,直接连接到一
    个授权资源.如何完成取决于目标方案和相关规范,类似规范定义原服务如何处理http访问.

    有关链接管理定义在第六章.

5.3.请求目标

    一旦获得了入站链接,客户端就可以发送请求消息,请求目标由目标URI派生.有4种不同形式目标,
    取决于请求方法和请求是否指向代理.
     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form
    最常用的请求形式是原始形式.
        origin-form    = absolute-path [ "?" query ]
    当直接请求源服务时,除CONNECT或服务OPTIONS请求意外,客户端只能发送路径并查询目标的
    组成作为请求目标.如果目标URI路径组件时空的,客户端必须发送"/"作为请求目标原始形式路径.
    还要发送主机首部字段,如5.4章节所定义的.

    例如,客户端想直接从原服务器检索标识为http://www.example.org/where?q=now的源,就会打开
    一个TCP链接连到"www.example.org"主机的80口,发送如下内容:
    GET /where?q=now HTTP/1.1
    Host: www.example.org
    随后请求消息的其它部分.

5.3.2绝对形式

    当请求代理,除CONNECT或OPTIONS请求外,客户端必须绝对形式的目标URI作为请求目标.
    absolute-form  = absolute-URI
    代理被要求为缓存中有效的请求服务,如果可能,向下一个服务代理或源服务发起同样的请求,作为
    客户代表.此类转发消息的要求定义在5.7章节.
    绝对形式请求行的例子:
    GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
    为了能让绝对形式的所有请求能够向未来的HTTP版本过渡,要求服务必须接受绝对形式的请求,
    即使HTTP/1.1客户端仅将请求发送给代理.

5.3.3授权形式

    授权形式的请求目标只是用于CONNECT请求([RFC7231]4.3.6章节).
    authority-form = authority
    当CONNECT请求通过一个或多个代理建立通道是,客户端必须发送目标授权组件作为请求目标.
    CONNECT www.example.com:80 HTTP/1.1

5.3.4星号通配形式

    星号请求目标形式仅用于服务范围的OPTIONS请求([RFC7231]4.3.7章节).
    asterisk-form = "*"
    当客户端希望为整个服务器请求选项是,与该服务特定命名资源相对,客户端必须使用"*"(%x2A)
    作为请求目标.例如:
    OPTIONS * HTTP/1.1
    如果代理接收到了绝对形式目标的OPTIONS求情,并且URI路径是空的,没有查询任何组件,那么在
    请求链路上最后一个代理必须发送"*"号请求目标转换给源服务器.

    如:
    OPTIONS http://www.example.org:8001 HTTP/1.1
    最后代理需要转换为:
    OPTIONS * HTTP/1.1
    Host: www.example.org:8001

5.4.主机

    请求中"Host"字段提供主机和端口信息,使源服务器能够区分资源,并为单个IP的多个主机名
    提供服务.
    Host = uri-host [ ":" port ] ; 章节 2.7.1

    所有HTTP/1.1客户端请求必须发送Host字段.如果目标URI包含授权组件,客户端必须发送标识
    组件的Host地址,除开用户信息子组件和"@"界定符(2.7.1章节).如果缺少授权或未定义目标
    URI,那么客户都必须发送一个空值的Host字段.

    由于主机字段是处理请求的关键,用户代理应当在请求行之后第一个生成主机字段.

    例如,一个请求<http://www.example.org/pub/WWW/>:
    GET /pub/WWW/ HTTP/1.1
    Host: www.example.org

    HTTP/1.1客户端请求必须发送主机字段,即使请求采用绝对形式,因为老的HTTP/1.0可能未实现
    Host字段,这样可以让HTTP/1.0的代理转发Host字段.

    当代理收到一个绝对形式的请求目标请求，代理必需忽略Host头字段，并使用请求目标中的主机
    信息来替换。转发此类请求是必需用请求目标生成新的Host字段，而非收到的Host字段的值。

    由于Host字段充当于应用级别的路由机制，常被恶意软件用来破坏共享缓存或重定向请求到其它
    服务器。如果拦截代理依赖于Host字段来转发请求，或使用共享的缓存键，会特别容易受到攻击。

    HTTP/1.1请求消息如果缺少Host字段或包含多个或无效的值，服务器都必需返回400(错误请求)。

5.5.有效的请求URI

    由于请求目标通常只包含用户代理URI的一部分，服务会重构目标为一个有效的请求URI保证正常
    处理。这种重构涉及服务本地配置和通信信息中的请求目标，主机地址，链接上下文。

    对用户代理来说，有效的请求URI就是目标URI.

    如果请求目标使用的是绝对形式，那么有效的请求URI是跟请求目标一样。除此之外，有效请求URI
    是在以下情况下构建：

    如果服务器或出站网关配置为有效请求URI提供了固定方案，除此之外，如果收到请求是TLS安全的
    TCP链接，有效的请求URI方案是"https";如果不是，那就是"http".

    如果服务器配置了固定授权组件，那么授权用于有效的请求URI.非则，如果当请求目标在授权模式下，
    有效请求URI的授权组件同请求目标一样。如果不是，当Host字段提供空值，那么授权组件与Host
    字段相同。除此之外，为服务器配置了默认权限组件名称，如果链接进入TCP端口不是默认的有效
    请求URI的方案，需要在作者组件后缀端口地址用":"冒号隔开。

    如果请求目标使用的是授权形式或星号通配形式，有效的请求URI组成的路径和查询组件是空的。
    除此之外，组合路径和查询组件与请求目标是一样的。

    一旦有效请求URI组件确定，就能通过串联方式组成绝对URI，"://"，作者，组合路径和查询组件。
    例：通过非安全TCP链接：
    GET /pub/WWW/TheProject.html HTTP/1.1
    Host: www.example.org:8080
    有效请求URI是：http://www.example.org:8080/pub/WWW/TheProject.html

    例2：安全TCP链接
    OPTIONS * HTTP/1.1
    Host: www.example.org
    有效请求URI是:https://www.example.org

    收到HTTP/1.0请求是缺少Host字段，可能需要启发(例如，检查URI路径中特定的主机部分内容)用于
    猜测有效的URI的作者组件。

    一旦构建有效的请求URI，源服务就会决定是否向改URI提供服务。例如，请求可能被有意或无意的指向
    错误，请求目标或Host字段值与上游主机或端口地址不一样。如果链接来自一个可信的网关，可能不一致；
    除此之外，可能是尝试绕过安全验证，诱导服务器提供非公开的内容，或攻击缓存。见第9章有关消息
    路由安全的注意事项。

5.6.响应关联到请求

    HTTP并不包含一个请求标识，用于关联请求和应答。因此，这个依赖于同一个链接上的应答顺序。
    每个请求的应答对同一个请求作最终应答。

    客户端如果有未完成的请求，那么需要按发送顺序讲请求保存在列表中，讲接收到的应答关联最高的
    请求，一直到最终应道。

5.7.消息转发

    就如2.3章节所述，在HTTP请求与应答过程中可以扮演很多角色。一些中介服务用于提高性能或可用性。
    一些用于控制访问或过滤内容。因此HTTP流具有类似于管道过滤器结构，并且没有固定限制，能够增强
    流。

    中介不会做为隧道通道，必需实现连接头部字段，如6.1章节指出的，并排除转法中仅用于传入链接的字段。

    中介服务不能转发给计息，除非受无线循环保护。通常，中介应当知道自己服务明个，包括自己的
    服务名，包括别名，局部变化或IP地址，响应可以直接回复。

7.7.1.通道

    Via首部字段表示存在的中间协议和接受者在用户代理和服务之间，或在源服务和客户端之间，类似于
    在email里的Received首部字段([RFC5322]部分)。Via可以用于追踪消息转发，避免循环请求，识别请
    求/应答链中发送方的协议。
    Via = 1#( received-protocol RWS received-by [ RWS comment ] )

    received-protocol = [ protocol-name "/" ] protocol-version
    received-by       = ( uri-host [ ":" port ] ) / pseudonym
    pseudonym         = token

    多个Via字段表示转发通过的每个代理或网关。每个中介都会添加自己有关接收消息的信息，从而根据
    转发接收者的顺序进行最终结果排序。

    代理必需发送适当的Via字段，如下所述，每个转发的消息。HTTP到HTTP的网关在每个入站请求必需发
    送Via字段，在转发应答可以发送Via字段。

    每个中介，received-protocol表示协议和协议版本用于上游发送信息。因此，Via字段记录了的协议，
    在整个请求/应答链都是可见，这样可以让下游接收者也能获知；这对于决定使用什么向后兼容的特性
    非常有用，或在以后的请求，为了简洁，当接收协议是HTTP时省略协议名称。

    received-by字段部分值通常是就接收服务器的主机地址和端口或转发消息的客户端。然而，如果真是
    主机被视为敏感数据，发送者可能会使用笔名代替。如果端口未提供，接收者可能认为是默认的TCP端
    口，如果有的话，用于received-protocol。

    发送者可以在Via字段写入注释，来表明每个接收者的软件。然而，所有注释都是可选的，并且接收者
    在转发前可以移除注释。

    例如，从HTTP/1.0用户代理向互联网代理代号"fred"发送请求，使用HTTP/1.1来转发请求向一个公共的
    p.example.net代理，最后完成向源服务www.example.com转发。服务器收到的Via字段：
    Via: 1.0 fred, 1.1 p.example.net

    通过门户网站类似完成防火墙功能的中介，是不应当暴露防火墙内部的主机与端口，除非设置了开启。
    所以这类中介都会用代号替换主机名，达到隐藏在防火墙后面主机的目的。

    如果条目用相同的协议，可以按序合并这类条目。例：
    Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
    合并后：
    Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
    发送者不应当合并条目，除非在同一个组织控制下，并且主机已经使用别名替换。发送者也不可以讲不
    同协议的值合并。

5.7.2.转换

    一些中介能够转换消息和负载的信息。例如，代理转换图片格式到达减少缓存或降低慢链接网络流量，
    然而，对一些关键的应用信息操作可能会出现问题，像医学影像或科学分析数据，这种情况下可以用完
    整性检查或数据签名来保证收到的负载信息是原始数据。

    设计或配置了根据语义修改消息的HTTP-HTTP代理称之为转换代理(修改，超出通常HTTP需要的处理。)
    对于发送者或下游接收者有意义。例如，转换代理可能扮演共享注释服务(修改响应包含对本地数据引用)
    ，一个恶意过滤，格式转码，或隐私过过滤。假定无论哪个客户端（或客户端组织）选择了代理，都需
    要这种转换。

    如果代理收到请求目标主机名不是全限定名，它可以将自己的域名加入到主机名中再转发。当请求目标含
    全限定域名时代理不能修改主机名称。

    代理不能修改绝对路径和查询部分的请求目标，再将其转发入站服务，除了将空路径使用"/"或"*"替换。

    代理可以通过应用或删除传输编码来修改消息体(第4章)。

    代理不能转换一个包含不转换缓存控制指示的负载内容。

    代理可以转换不含不转换缓存控制指示消息的负载内容。代理在转换负载内容时，必需在首部增加警告
    字段warn-code 214("应用转换")，如果消息中已经有了就不需要再加([RFC7234]5.5章节)。对于200的
    返回响应可以修改应答状态为203来告知下游接收者应用了转换。([RFC7231]6.3.4章节)。

    代理不应当修改有关链接点信息的字段，资源状态，或字段定义明确可以修改，或对安全有必要的修改。

6.链接管理

    HTTP消息传递独立于基础传输层或会话层链接协议。HTTP仅假定按顺序传输请求和相应按顺序传递响应的
    安全传输。HTTP请求和应答结构映射到传输层的数据单元超出本规范范围。

    如5.2章节所述，HTTP交互使用的协议由客户端配置和目标URI决定。例如，"http"URI方案(2.7.1章节)表
    明默认的基于IP的TCP链接，默认端口80，单客户端可以配置使用代理，通过另一些链接，端口，或协议。

    HTTP实现有望参与链接管理，这些包括保持当前链接状态，建立新的链接或重用存在的链接，处理接收到
    的消息，检测失败链接，和关闭每个链接。大多数客户端并行保持多个链接，包括多个链接在一个服务点。
    多数服务设计为保持上千的链接在同一时刻，同事控制请求队列合理利用并检测拒绝攻击。

6.1.链接

    首部Connection字段允许发送者表明当前链接需要的控制选项。在转发消息前，代理或网关必需删除或重设
    或修改任何接收到的链接选项，为了避免引起下游接收者困惑。

    如果提供了除Connection之外有关控制当前链接相关信息的字段，发送者必需将相应的字段名列在Connection
    字段里。在转发消息前，代理或网关必需解析收到的Connection字段值，删除每个在此字段中的链接属性，
    并删除Connection字段(或使用自己的链接属性替换后再转发)。

    因此，Connection字段提供了一种区别于其它字段的声明，就是它仅用于直接接收者("hop-by-hop")，其
    它字段作用于传输链上的所有接收者("end-to-end"),消息可以自我描述，允许将来部署特定的链接扩展，
    而不必担心将来被老的中介恶意转发。

    Connection字段值语法：
    Connection        = 1#connection-option
    connection-option = token

    Connection-option是大小写不敏感。

    发送者不可以发送对应用于所有接收者的负载信息的链接属性字段。例如，Cache_Control永远不适合作为
    链接属性([RFC7234]5.2章节)。

    链接属性不总是与首部字段相对应，因为没有参数与链接选项相关联，则不需要特定于链接的首部字段。相
    反的，一个特定于链接字段没有对应的链接选项，通常表明字段被中介不当转发，接收者应当忽略。

    当定义新的链接选项，作者应当先查看已经存在的字段，确保新的链接选项名称已经部署存在。定义新的链
    接选项实际上会保留该潜在的字段名，以携带与链接选项相关的信息，因为发件人将该字段名用于其它任何
    内容都是不明智的。

    "close"链接选项表明链接在完成响应后关闭。例如，
    Connection: close

    无论请求或是应答字段都表示发送者在当前请求/应答完成后将要关闭链接(6.6章节)。

    不支持持久链接的客户端必需在每个发送的请求消息中标明"close"链接选项。

    不支持持久链接的服务端必需每个响应消息中标明"close"，同时没有1xx(信息)状态代码。

6.2.建立

    这个内容超出了本规范描述范围，链接建立通过传输层或会话层协议。每个链接仅用于一个传输链。

6.3.持久

    HTTP/1.1默认使用"持久链接"，允许多个请求和应答由一个链接传输。"close"链接选项表示当前请求/应答
    后链接不会持久。HTTP实现应当支持持久链接。

    接收者如果判断一个链接是否是持久，根据最近接收到消息的协议版本和链接首字段：
    *如果"close"存在，当前应答后链接不会持久；否则
    *如果协议是HTTP/1.1或更高，当前应答后链接将保持持久；否则
    *如果协议是HTTP/1.0，"keep-alive"链接选项存在，接收者不是代理，并接收者期望遵循HTTP/1.0
    "keep-alive"的机制，那么当前应答后链接保持持久；否则
    当前应答后链接将关闭。

    客户端可以在持久链接上发送附加请求，直到接收到"close"链接选项，或收到HTTP/1.0应答没有
    "keep-alive"链接选项。

    为例保持持久，链接上所有消息需要自己定义消息的长度(没有定义关闭链接链接)，如3.3章节描述。服务
    必需读取整个请求消息体，或在发送应答后关闭链接，因为否则持久链接保持的数据会被误认为是下一个请
    求。同样的，客户端如果想为下个请求使用同样的链接，必需读取整个应答消息。

    HTTP/1.0的代理服务不可以保持持久链接(见[RFC2068]19.7.1有关Keep-Alive字段实现的信息和讨论)。

    见附录A.1.2更多关于向后HTTP/1.0客户端兼容的信息。

6.3.1.重试请求

    链接可以在任何时候有意或无意被关闭。实现应当能够从预期的异步关闭事件中回复。

    如果一个入站链接过早被关闭，客户端可以开启新的链接，重复发送中止的幂等请求序列([RFC7231]4.2.2)
    。代理一定不能自动重试非幂等的请求。

    用户代理不能自动重试非幂等的请求方法，除非确切知道请求是幂等的，不管用什么方法，或通过某种方式
    检测到从未应用的原始请求。例如，一个客户代理知道(通过设计或配置)给定资源的POST请求是安全的可重
    复提交。同样的，用户代理特别设计来草在版本控制库，可以通过检查目标资源修订修复部分失败，回复或
    修复任何部分应用修改，自动重试失败请求。

    客户端不应当自动重试失败的重试。

6.3.2.管道流水

    支持持久链接的客户端可以"pipeline"管道流水试的请求(发送多个请求中间不等待每个的响应文成)。服务
    可以序列同步并行处理请求，这些请求要是安全方法([RFC7231]4.2.1)，但必须发送响应的顺序与请求的顺
    序保持对应一致。

    如果管道请求时链接提前关闭，没有接收到所有的应答，客户端应当重试未应答的请求。在失败链接后(链
    接没有被服务器明确的关闭)重试管道请求时，客户端建立链接后不得立即进行管道请求，因此之前的请求
    可能引起一个错误的响应可能会被丢失，如果多个请求提前关闭可能会引起再次丢失。(见TCP重置问题描述
    6.6章节)。

    幂等方法([RGC7231]4.2.2)对于管道是很重要的，因为它能够在链接失败后自动重试。非幂等方法是不应当
    使用管道请求，直到收到了最终状态应答，除非用户代理有检测并从管道请求序列失败恢复的方法。

    中介可以同样管道式转发入站，因为可以通过出站代理确定那个可以安全的管道请求。如果入站链接在收到
    应答前失败，管道中介可以尝试重试幂等请求方法；否则，中间应当转发收到的应答，关闭对应的出站链接
    。这样出站用户代理可以相应的进行恢复。

6.4.并发

    客户端应该限制同时打开的链接数量。

    之前HTTP版本规定了一个链接数量作为上线，但是发现对于很多应用来说是不切实际的。结果就是，本规范
    不规定最大连接数，但是，鼓励客户端打开多个连接时保持守护。

    通常使用多链接来解决线头阻塞问题，当一个请求需要服务端大量处理或大负载时需要时间，这时候就会阻
    塞同一个链接上的后面的请求。然而，每个服务器都小号资源。此外，使用多链接可能会引起网络阻塞的不
    良副作用。

    注意，服务器可能会拒绝它认为有可能的具有流量或"服务拒绝"特性的攻击，如过多的链接来自一个客户端。

6.5.失败和超时

    服务通常具有一些超时值，当超过该时间后将不再保持不活动的链接。该只对于代理服务可能更具价值，因
    为    客户端可能会有更多的链接通过同一个代理。使用持久代理是不需要超时的，不管客户端还是服务端。

    客户端和服务端应该正常关闭链接。实现应该常监控打开的链接是否接收到关闭信号，并做出适当回应。因
    为迅速关闭连接的两端都可以回收分配的系统资源。

    服务应当支持持久链接，可能的话，并且支持基础传输流充值机制来解决暂时的过载，而不是结束链接并期
    望客户端重试。后一种技术可能会加剧网络阻塞。

    客户端在传输请求发送消息体时，应当监控网络链接是否有错误的响应。如果客户端看到了响应，说明服务
    器不希望接收消息并关闭链接，客户端应当立即停止传输并关闭其链接。

6.6.清除

    首部的Connection字段(6.1章节)提供"close"链接选项，当发送者希望在完成当前请求或应答后关闭链接。

    客户端在发送"close"后，不能再链接上继续请求，并必需在收到对应响应消息后，关闭链接。

    服务端在接收到"close"后需要在最终响应中包含"close",发送完成后关闭链接。同样在处理完后，不能再
    继续使用该链接发送请求。

    如果服务立即关闭TCP链接，就可能出现客户端将无法读取最后HTTP响应的重大风险。如果服务端接收到额
    外来自客户端的数据，而链接已完全关闭，就像客户端在接收到服务器响应之前，发送了另一个请求，服务
    端的TCP栈将会发送重置包给客户端；不幸的是，重置包可能会在解析前擦除未输入缓存。

    为了避免TCP的重置包问题，服务器通常分阶段关闭链接。首先，服务器执行半关闭，关闭写入端的读/写链
    接。此时服务端继续从链接读取，知道接收到对应的close，或服务器某种理由确信TCP栈接收到了客户端的
    确认包，确认其收到了服务的最后的响应。最终，服务器完全关闭链接。

    不清楚重置问题是不是TCP独有的，或可能其它传输协议也有这种问题。

6.7.升级

    "Upgrade"字段提供一种简单的机制，在同样的连接上从HTTP/1.1转换到其它协议。客户端可以Upgrade字段
    设置一系列的协议，邀请服务器切换到其中的一种或多种协议，按优先顺序降序，服务器可以忽略Upgrade，
    如果期望继续使用当前的协议。Upgrade不能强制要求更换协议。
    Upgrade          = 1#protocol

    protocol         = protocol-name ["/" protocol-version]
    protocol-name    = token
    protocol-version = token

    服务器在发送101(切换协议)响应时必须包含Upgrade字段说明切换到那个协议；如果多层协议切换，发送者
    必须按顺序列出协议。服务器不能切换到客户端未列出的协议。服务器选择协议的时候可以忽略客户端所列
    的优先级，基于一些其它因素，例如请求性质或服务器当前负载。

    服务器返回426(需要升级)响应必需包换Upgrade字段说明可以接受的协议，按降序排列。

    服务器可以在任何响应中发送Upgrade字段，说明其支持的协议，按降序排列。

    客户端发送示例：
    GET /hello.txt HTTP/1.1
    Host: www.example.com
    Connection: upgrade
    Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

    应用层通讯能力于特性完全依赖于所选的新的协议。然而，在发送101响应之后，服务器会继续响应原始请求
    ，就像在新的协议中收到请求一样。(即，在切换协议后，服务器依旧有一个未处理的请求，这样做就无需在
    重复请求)。

    例如，如果在GET请求中收到Upgrade字段，服务器决定切换协议，首先HTTP/1.1响应101(切换协议)消息，随
    后立即用新的协议响应GET目标资源。这样可以允许链接升级HTTP相同语义的协议不用，而无需花费额外的往
    返时间。除非收到消息语义能被新的协议接受，否则服务器不能切换协议；OPTIONS请求能被任何协议接受。
    以下响应例子假设了以上的情况。
    请求：
    HTTP/1.1 101 Switching Protocols
    Connection: upgrade
    Upgrade: HTTP/2.0
    [...数据流以适当的响应切换到HTTP/2.0(如新协议所定义)的"GET /hello.txt"请求]

    当Upgrade被发送，发送者必需发送Connection字段包换"upgrade"链接选项，为了避免Upgrade被中介偶然
    转发，未实现所列的协议。服务器必需忽略HTTP/1.0所请求的Upgrade字段。

    客户端在完成请求之前，不能在链接上开始使用升级协议(即，客户端无法更改在发送消息中间的协议)。如
    果服务器同时收到了了带Upgrade和Expect字段期望"100-continue"([RFC7231]5.1.1章节)，服务器必需在
    发送101(切换协议)响应前发送100(继续)。

    Upgrade字段仅用于在现有链接上切换协议；无法用于切换底层链接协议，同样不能切换现有的通讯到不同的
    链接。为此目的，更适合使用3xx(重定向)响应([RFC7231]6.4章节)。

    本规范仅定义HTTP协议，用于超文本协议，如HTTP2.6章节版本规则定义，规范的未来更新。应当使用第8.6
    节中定义的注册程序向IANA注册其他令牌。

7.ABNF扩展:#rule

    #rule对ABNF扩展规则[RFC5234]用于提高一些字段定义值的可读性。

    "#"定义，如"*",用于定义逗号分隔开列表袁术。完整格式是"<n>#<m>element"表示至少<n>个和最多<m>个
    元素，每个被单个","和空白(OWS)隔开的元素。

    在任何使用列表的构造中，发送者不可以产生空列表。或则说，发送者必需生成一个满足一下句法的列表：
    1#element => element*(OWS","OWS element)
    并且
    #element => [1#element]
    and for n >= 1 and m > 1:
    <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )

    为了与旧版列表规则兼容，接收者必需解析和忽略一定合理数量的空列表元素：足以处理发送者合并值得通
    常错误，但不足以将其用作拒绝服务机制。换一种说法，接收者必需能接受一下语法的列表：
    #element => [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
    1#element => *( "," OWS ) element *( OWS "," [ OWS element ] )
    空元素不会增加现有元素的数量。例如，
    example-list      = 1#example-list-elmt
    example-list-elmt = token ; see Section 3.2.6

    以下是有效列表样例(不包括双引号，只是为了分隔界别)：
    "foo,bar"
    "foo ,bar,"
    "foo , ,bar,charlie   "

    相比，以下无效值，因为至少需要一个元素：
    ""
    ","
    ",   ,"

    附录B展示了已经扩展过结构的的集合ABNF。


8.IANA注意事项

8.1.首字段注册

    HTTP首字段注册在"Message Headers"保存在<http://www.iana.org/assignments/message-headers/>.

    本文定义了以下HTTP首部字段，"永久首字段名"注册已经更新(见[BCP90])。
    +-------------------+----------+----------+---------------+
    | Header Field Name | Protocol | Status   | Reference     |
    +-------------------+----------+----------+---------------+
    | Connection        | http     | standard | Section 6.1   |
    | Content-Length    | http     | standard | Section 3.3.2 |
    | Host              | http     | standard | Section 5.4   |
    | TE                | http     | standard | Section 4.3   |
    | Trailer           | http     | standard | Section 4.4   |
    | Transfer-Encoding | http     | standard | Section 3.3.1 |
    | Upgrade           | http     | standard | Section 6.7   |
    | Via               | http     | standard | Section 5.7.1 |
    +-------------------+----------+----------+---------------+

    此外，"Close"字段被注册为"reserved"，因为HTTP字段名与链接选项Connection的"close"可能冲突。
    +-------------------+----------+----------+-------------+
    | Header Field Name | Protocol | Status   | Reference   |
    +-------------------+----------+----------+-------------+
    | Close             | http     | reserved | Section 8.1 |
    +-------------------+----------+----------+-------------+

    并更控制："IETF (iesg@ietf.org) - Internet Engineering Task Force". 互联网工程特别组。

8.2.URI注册方案

    IANA记录注册URI方案[BCP115]<http://www.iana.org/assignments/uri-schemes/>.
    +------------+------------------------------------+---------------+
    | URI Scheme | Description                        | Reference     |
    +------------+------------------------------------+---------------+
    | http       | Hypertext Transfer Protocol        | Section 2.7.1 |
    | https      | Hypertext Transfer Protocol Secure | Section 2.7.2 |
    +------------+------------------------------------+---------------+

8.3.互联网媒体类型注册

    IANA注册互联网媒体类型[BCP13]<http://www.iana.org/assignments/media-types>.

    本规范媒体类型"message/http"与"application/http".已在IANA注册。

8.3.1.互联网媒体类型message/http

    message/http类型用于封装单个HTTP请求或响应，遵守所有有关行长和编码的“消息”类型的MIME限制。
    类型名称：message
    子类型名称：http
    必要参数：N/A
    可选参数：version, msgtype
        version:封装消息的HTTP-version版本(例如，"1.1").如果不存在，可以从消息体的第一行确定。
        msgtype:消息类型--"request"或"response"。如果不存在，如果不存在，可以从消息踢得第一行确定。
    编码注意：仅"7bit","8bit",或"binary"允许使用。
    安全注意事项：见第9章
    互通性：N/A
    发布规格：本规范(见第3.3.1章节)。
    应用媒体类型：N/A
    分片标识符:N/A
    附加信息：
        幻数：N/A
        已弃用别名：N/A
        文件扩展:N/A
        Macintosh文件类型代码：N/A
    获取更多信息相关人员和电子邮件地址：
        见作者地址部分。
    预期用途:COMMON
    使用限制：N/A
    作者：见作者地址部分。
    变更控制：IESG

8.3.2.互联网媒体类型application/http

    application/http类型用于封装一个或多个HTTP管道请求或响应消息(不混杂)。
    类型名称：application
    子类型名称：http
    必要参数：N/A
    可选参数：version, msgtype
        version:封装消息的HTTP-version版本(例如，"1.1").如果不存在，可以从消息体的第一行确定。
        msgtype:消息类型--"request"或"response"。如果不存在，如果不存在，可以从消息踢得第一行确定。
    编码注意：仅"7bit","8bit",或"binary"允许使用。
    安全注意事项：见第9章
    互通性：N/A
    发布规格：本规范(见第3.3.1章节)。
    应用媒体类型：N/A
    分片标识符:N/A
    附加信息：
        幻数：N/A
        已弃用别名：N/A
        文件扩展:N/A
        Macintosh文件类型代码：N/A
    获取更多信息相关人员和电子邮件地址：
        见作者地址部分。
    预期用途:COMMON
    使用限制：N/A
    作者：见作者地址部分。
    变更控制：IESG

8.4.传输编码注册

    "HTTP Transfer Coding Registry"定义了传输编码名称的命名空间。
    在 <http://www.iana.org/assignments/http-parameters> 维护.

    不测必需包含以下字段：
    -名称
    -描述
    -指向规范文本的指针
    传输编码名称不能与内容编码重叠([RFC7231]第3.1.2.1章节)除非编码转换是相同的，就像第4.2章定义的
    压缩编码。

    相该命名空间增加值必需经过IETF检阅([RFC5226]第4.1章节)，必需符合传输编码规范定义的目的。

    使用程序名称定义编码名称是不可取的，不建议使用编码。

8.4.2.注册

    已经更新的注册编码：
    +------------+--------------------------------------+---------------+
    | Name       | Description                          | Reference     |
    +------------+--------------------------------------+---------------+
    | chunked    | Transfer in a series of chunks       | Section 4.1   |
    | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
    | deflate    | "deflate" compressed data            | Section 4.2.2 |
    |            | ([RFC1951]) inside the "zlib" data   |               |
    |            | format ([RFC1950])                   |               |
    | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
    | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
    | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
    +------------+--------------------------------------+---------------+

8.5.内容编码注册

    <http://www.iana.org/assignments/http-parameters>维护.
    +------------+--------------------------------------+---------------+
    | Name       | Description                          | Reference     |
    +------------+--------------------------------------+---------------+
    | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
    | deflate    | "deflate" compressed data            | Section 4.2.2 |
    |            | ([RFC1951]) inside the "zlib" data   |               |
    |            | format ([RFC1950])                   |               |
    | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
    | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
    | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
    +------------+--------------------------------------+---------------+

8.6.升级令牌注册

    超文本协议升级令牌注册定义了协议令牌名称标识命名空间，用于升级字段。
    <http://www.iana.org/assignments/http-upgrade-tokens>.

8.6.1.程序

    每个注册协议名称与联系信息相关，有关链接如何被使用细节相关一些列可选项。

    注册基于"First Come First Served"(见[RFC5226]4.1章节)，遵守以下规则：
    1.协议令牌名，一旦注册，永久生效。
    2.注册必须制定注册责任方。
    3.注册必需制定联系点。
    4.注册可以定制一份跟命名相关的规范，不需要公开可用。
    5.注册应该注明预期相关的一些协议版本。
    6.责任方可以随时会发生边哈。IANA会保留变更记录，并应要求提供它们。
    7.IESG可以重新分配责任方。通常发生在责任方无法联系的时候。

    HTTP Upgrade令牌的注册流程定义在[RFC2817]7.2章节。

8.6.2.令牌注册

    以下列出了"HTTP"完整的已更新的注册令牌：
    +-------+----------------------+----------------------+-------------+
    | Value | Description          | Expected Version     | Reference   |
    |       |                      | Tokens               |             |
    +-------+----------------------+----------------------+-------------+
    | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | Section 2.6 |
    |       | Protocol             | (e.g, "2.0")         |             |
    +-------+----------------------+----------------------+-------------+

    责任方："IETF(iesg@ietf.org)-互联网工程特别工作组"。

9.安全注意事项

    本节主要是提醒开发者，信息提供，用户有关HTTP消息的安全，有关语法，解析，路由。安全相关HTTP
    语义和载体地址在[RFC7231].

9.1.建立机构

    HTTP依赖于机构响应策略：由URI标识的目标机构决定的响应，给出目标资源的状态。提供非机构来源的应
    答，如共享缓存，通常用于提升执行性能和可靠性，单仅限于可信任源或不可信任响应能被安全使用。

    不幸的是，建立机构是很难得，例如，钓鱼是对用户对网站知觉的攻击，通过战士类似的超文本内容来混淆
    这种知觉，可能用户信息混淆了网站名(见2.7.1).通过用户代理让用户能够简便的查看目标URI能减少钓鱼
    攻击的影响，通过明显区分用户信息，通过不发送存储的凭证和缓存，当内容来自未知或不可信来源。

    当网站部分使用注册名称是，HTTP URI方案(2.7.1部分)使用用户本地域名解析来确定哪里能获得响应。这
    意味着任何攻击用户网络主机地址表，缓存域名，或域名解析库成为主要攻击建立网站的途径。同样的，
    用户选择域名服务器(DNS)，从中获得服务器的解析结果，和服务器结构层次，可能影响地址王赞的映射；
    DNS安全扩展(DNSSEC,[RFC4022])是一种提供授权的方式。

    另外，在获取IP地址后，为"http"建立授权很容易受到互联网协议路由攻击。

    "https"方案(2.7.2)旨在建立授权时避免很多潜在的攻击，只要是协商的TLS是安全的，客户端会验证通
    讯的服务器标志符合目标URI的网址([FRC2818]).正确实施此类验证可能很困难。

9.2.中介的风险

    就本质而言，HTTP中介就是中间人，因此，这代表了中间人攻击的机会。中介运行系统受损可能会导致严重
    的安全和隐私问题。中间可能有权方案安全相关的信息，个人或机构的信息，属于用户和内容提供者的所有
    权信息。受损的中间，或不关心安全和隐私的中介，可能被用于实施各种潜在的攻击。

    有共享缓存功能的中介特别容易受到缓存攻击，如[RFC7234]8中介所述。实施者需要考虑其设计和编码对隐
    私和安全的影响，还有提供给操作者的配置选项(特别是默认配置)。

    用户需要意识到，中介不必运行中介的人更值得信赖；HTTP本身无法解决这个问题。

9.3.协议元素长度攻击

    因为HTTP主要使用文本，字符分隔字段，解析器通常容易受到长数据流攻击，特别是在实现期望没有预定义
    长度的协议元素情况下。

    为了促进交互性，比较意见设置请求行和首字段的最小先知。这些最小建议，选择即使实施资源有限的也可
    以得到；期望更多的实现选择更高的限制。

    服务可以拒绝请求目标过长或请求负载过大的消息。HTTP扩展定义了有关能力限制的状态码2.

    接收者应当小心处理其他协议元素的范围限制，包括请求方法，响应状态码解析，首字段名，数字值，消息
    块。无法限制这些处理可能会导致缓存溢出，数学运算溢出，增加拒绝服务攻击。

9.4.响应拆分

    响应拆分是一种常用的技术，用于对web使用的各种攻击，利用HTTP消息框架基于行的本质和持久连接上请求
    和响应有序关联。当请求通过共享缓存时，此技术可能更加有害。

    响应拆分利用服务器(通常是应用服务器)中的漏洞，攻击者可以在请求参数内发送编码数据，稍后再任何响
    应首解码回显。如果解码后的数据精心设计过看起来像响应结束，随后的回应已经开始，响应被拆分并第二
    个响应内容已经被攻击者控制。攻击者可以在同一个连接上发送任何请求，欺骗接收者相信第二个拆分的请
    求是权威的应答。

    例如，有参数请求目标的请求被应用服务器读取，在重定向中重复使用，结果在同样的参数中，在同样的响
    应为止字段中回显。如果参数被应用编码，且编码不正确放在响应字段中，攻击者可以编码CRLF字节，其他
    内容让应用单独响应看起来是两个或多个响应。

    通常防御响应拆分的方法是过滤请求数据中看起来像CR和LF的编码(例如，"%0D"和"%0A")。然而，假设应用
    付耍起仅执行URI解码，而不是像字符集转码那样模糊的数据转换，XML实体转码，base64编码，sprintf重新
    格式化，等等。更有效的缓解方法是防止服务核心协议库以外的所有地方发送CR或LF，这意味着将首字段输
    出闲置在API，过滤错误字节并禁止应用服务直接写入协议流。

9.5.请求走私

    利用个收件人间协议解析差别隐藏附加明显无伤害内容的请求。类似应答拆分，请求走私可以导致HTTP各种
    攻击。

    本规范已经介绍请求解析新的需求，特别是第3.3.3章节消息框架，有效的减少请求走私有效性。

9.6.消息完整性

    HTTP未定义特别的机制来确保消息完整，相对依赖于基础传输协议的错误检查能力，使用长度或块分割框架
    检测完整性。附加完整机制，如hash功能或数字签名应用于内容，可选的通过添加扩展元首字段。历史上，
    大多数HTTP通讯证明缺少单独完整性机制的合理性。但是，盛行的HTTP通信机制环境，导致在对消息完整性
    检验在关键环境变得越来越重要。

    鼓励用户代理实现可配置手段检验完整性和失败报告，这些方法可以在需要完整性检测的环境中启用。例如：
    浏览器用来查看医疗历史或药物作用信息，当信息被检测到不完整，过期，或传输过程中损失。可以通过用
    户代理扩展或响应中存在完整消息元数据来启用。至少，用户代理应当提供一些指示让用户区别完整和不完
    整消息响应。

9.7.消息保密

    HTTP基于传输协议提供消息保密。HTTP特别设计基于传输协议，这样能够用于很多不同加密格式链接，通过
    URI方案标识或用户代理配置选择。

    "https"方案用于源标识需要加密链接，如2.7.2章节所述。

9.8.服务器日志信息的隐私

    服务器处于保存用户一段时间内请求的数据信息的为止，可以标识他们的阅读习惯或感兴趣的内容。特别是，
    中介收集的日志信息通常包含了用户代理交互，跨越多个站点，可以追溯到单个用户。

    HTTP日志信息本质上是保密的；它的处理通常收到法律法规保护。日志信息需要安全存储，并遵循适当指导
    进行分析。在各个条目中对个人匿名处理有助于保密，但是通常这还不足以防止基于与其他访问特征的相关
    性来重新标识真实的日志跟踪。这样，即使密钥是假名，键入特定客户端的访问跟踪也不安全。

    为了最大减少盗窃和意外发布风险，日志信息应当清除个人身份信息，包括用户标识，IP地址，以及用户提
    供的查询条件，一旦该信息不再需要用于安全性，审计或欺诈性控制。

10.致谢

    HTTP/1.1是建立在RFC 1945, RFC 2068, RFC 2145, and RFC 2616基础上，包括以前作者做出的巨大贡献，
    编者，和工作组主席：Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,Henrik Frystyk Nielsen,
    Jim Gettys, Jeffrey C. Mogul, Larry Masinter,and Paul J. Leach.  Mark Nottingham 担任工作组主席
    期间监督工作。

    后续内容不再翻译，参见原版。
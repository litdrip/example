互联网特别工作组(IETF)                   R. Fielding, Ed.
征求意见:7231                                       Adobe
历史:2616                                 J. Reschke, Ed.
更新:2817                                      greenbytes
类别：标准追踪                                  June 2014
国际标准序号：2070-1721


        超文本传输协议(HTTP/1.1)：语义和内容

摘要

    超文本传输协议(HTTP)是为了分布式、协作、超文本信息系统开发的无状态应用层协议。
    本文当定义HTTP/1.1消息语义，如请求方法，请求头部字段，响应状态代码，响应头部字
    段，以及承载的信息(元数据和内容体)和内容协商机制。

备忘录

    本文是互联网标准追踪文档。

    本文由互联网工程特别工作组(IETF)编写。代表IETF社区的共识。已获得公共审查，互联
    网工程指导小组(IESG)批准发布。更多有关互联网标准信息见RFC5741第2章。

    有关本文当前状态信息，任何错误，以及如何提供回馈可以从
    http://www.rfc-editor.org/info/rfc7231 获得.

版权声明

    版权(c)2014 IETF信托，并确定为文档作者。保留所有权利。

    本文档受BCP78约束，IETF信托有关IETF文档法律规定
    (http://trustee.ietf.org/license-info)自本文档发布起生效。请仔细阅读，因为它描
    述了你对本文档的权利和限制。从本文提取的代码组件必需包含简体BSD许可，在信托法
    律规定的第4.e章节有诉，并不提供保证。

    本文档可能包含来自2008年11月10日之前发布的IETF文档或IETF贡献文档的内容。拥有这
    类内容版权的作者可能没有授权IETF信托在IETF标准流程之外修改。在未获取足够的许可
    下，本文档不得在IETF标准流程之外修改，并且其衍生产品也不可能在IETF标准流程之外
    创建，除了格式化发布或翻译成其它语言除了英语。


目录

    1.引言
        1.1.一致性和错误处理
        1.2.语法符号
    2.资源
    3.表达
        3.1.元数据表达
            3.1.1.处理表达元数据
            3.1.2.压缩或完整性编码
            3.1.3.受众语言
            3.1.4.标识
        3.2.数据表达
        3.3.承载语义
        3.4.内容协商
            3.4.1.主动协商
            3.4.2.反应协商
    4.请求方法
        4.1.概要
        4.2.常用方法属性
            4.2.1.安全方法
            4.2.2.幂等方法
            4.2.3.可缓存方法
        4.3.方法定义
            4.3.1.GET
            4.3.2.HEAD
            4.3.3.POST
            4.3.4.PUT
            4.3.5.DELETE
            4.3.6.CONNECT
            4.3.7.OPTIONS
            4.3.8.TRACE
    5.请求头部字段
        5.1.控制
            5.1.1.期望
            5.1.2.最大转发
        5.2.条件
        5.3.内容协商
            5.3.1.质量值
            5.3.2.Accept
            5.3.3.Accept-Charset
            5.3.4.Accept-Encoding
            5.3.4.Accept-Language
        5.4.授权证书
        5.5.请求上下文
            5.5.1.来源
            5.5.2.参考
            5.5.3.用户代理
    6.响应状态代码
        6.1.状态代码概要
        6.2.信息 1xx
            6.2.1.100 继续
            6.2.2.101 切换协议
        6.3.成功 2xx
            6.3.1.200 OK
            6.3.2.201 创建
            6.3.3.202 接受
            6.3.4.203 非权威信息
            6.3.5.204 无内容
            6.3.6.205 重置内容
        6.4.重定向 3xx
            6.4.1.300 多项选择
            6.4.2.301 永久转移
            6.4.3.302 查找
            6.4.4.303 其它
            6.4.5.305 用户代理
            6.4.6.306 (未使用)
            6.4.7.307 临时重定向
        6.5.客户端错误 4xx
            6.5.1.400 错误请求
            6.5.2.402 支付请求
            6.5.3.403 禁止
            6.5.4.404 未找到
            6.5.5.405 未允许的方法
            6.5.6.406 不可接受
            6.5.7.408 请求超时
            6.5.8.409 冲突
            6.5.9.410 离去
            6.5.10.411 长度需求
            6.5.11.413 承载过大
            6.5.12.414 URI过长
            6.5.13.415 不支持的媒体类型
            6.5.14.417 预期失败
            6.5.15.426 升级需求
        6.6.服务错误 5xx
            6.6.1.500 服务内部错误
            6.6.2.501 未实现
            6.6.3.502 错误网关
            6.6.4.503 服务不可用
            6.6.5.504 网关超时
            6.6.6.505 HTTP版本不支持
    7.请求头字段
        7.1.控制数据
            7.1.1.起始日期
            7.1.2.位置
            7.1.3.重试后
            7.1.4.变化
        7.2.验证头字段
        7.3.认证
        7.4.响应上下文
            7.4.1.允许
            7.4.2.服务
    8.IANA 注意事项
        8.1.方法注册
            8.1.1.程序
            8.1.2.新方法的注意事项
            8.1.3.注册
        8.2.注册状态
            8.2.1.程序
            8.2.2.新状态码注意事项
            8.2.3.注册
        8.3.头字段注册
            8.3.1.新字段注意事项
            8.3.2.注册
        8.4.内容编码注册
            8.4.1.程序
            8.4.2.注册
    9.安全注意事项
        9.1.基于文件和路径名称攻击
        9.2.基于命令，编码，查询注入攻击
        9.3.个人信息泄露
        9.4.URI敏感信息泄露
        9.5.重定向后分段泄露
        9.6.产品信息泄露
        9.7.浏览器指纹
    10.致谢
    11.参考
        11.1.规范参考
        11.2.内容参考
    附录 A. HTTP和MIME区别
        A.1.MIME版本
        A.2.转换规范格式
        A.3.数据格式转换
        A.4.内容编码转换
        A.5.传输编码转换
        A.6.MHTML和行长度限制
    附录 B. 自RFC 2616修改
    附录 C. ABNF引入
    服务 D. ABNF集
    索引


1.引言

    超文本传输协议消息是请求也是响应。服务监听客户请求，解析每个收到的消息，解释
    和所请求目标有关的消息的语义，再通过一个或多个应答消息回复。客户端构造请求传
    达到特定意图，检查收到的响应是否到达目标，并决定如何解释结果。文档根据
    [RFC7230]中定义的体系结构定义了HTTP/1.1请求与应答语义。

    HTTP提供了用于资源交互统一接口(第二章)，不论器类型，性质，或实现，通过表示的
    操做和转移(第三章)。

    HTTP语义包含了请求定义的意图(第4章)，对于那些可能在头字段描述的语义扩展(第5
    章)，状态码表示机器可读响应含义(第6章)，另一些控制数据和资源元数据的含义可能
    在响头字段(第7部分).

    描述接收者如何解释承载数据的元数据也有定义解释，可能影响内容选择的头字段，以
    及各种选择算法统称为内容协商(第3.4章节)。

1.1.一致性和错误处理

    关键词"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT","SHOULD",
    "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"同[RFC2119]的解释。

    [RFC7230]第2.5章节定义了错误处理的符合性标准和注意事项。

1.2.语法符号

    本规范使用扩展的ABNF符号[RFC5234]，[RFC7230]第7章定义，允许使用'#'运算符紧凑
    的定义逗号分隔列表(类似'*'表示重复)。附录C描述其他文档导入规则。附录D展示了
    收集的语法，所有列表运算均扩展为ABNF符号。

    本规范使用术语"character", "character encoding scheme", "charset", and
    "protocol element" 就像[RFC6365]所定义.

2.资源

    HTTP请求目标被称为"资源"。HTTP没有限定资源性质；仅仅定义了可用于资源交互的接
    口。每个资源由Uniform Resource Identifier(URI)标识，如[RFC7230]2.7章节描述。

    客户端构造HTTP/1.1请求消息时，以多种形式之一发送目标URI，定义在[RFC7230]第5.3
    章节。当服务接收到请求时，会构建有效的URI目标请求([RFC7230第5.5章节)。

    HTTP设计目标之一是将资源标识与请求语义分离，通过请求语义赋予请求方法(第4章)和
    一些请求的头字段(第5章)。如果方法语义和URI本身隐含的语义有冲突，如4.2.1章节所
    描述，方法语义优先。

3.表达

    考虑到资源可以是任何事物，同时HTTP提供的统一接口像是窗户，只有通过另一侧的独
    立角色传递消息，才能观察到这种行为并采取行动，需要一个抽象的来表示交流物的当
    前或期望状态。抽象称为表达[REST]。

    就HTTP而言，表达是反映资源过去、当前、期望状态的信息，因此，源服务使用了一些
    算法来选择一个最适合给定请求的表达，通常基于内容协商。选择表达用来为条件请求
    提供数据和元数据并为200(OK)和304(未修改)构造承载响应GET(4.3.1章节)。

3.1.表示元数据

    头字段提供了元数据表达。当消息包涵承载数据体，表达头字段描述了如何解析封装在
    消息体里的数据。在响应HEAD请求的应答里，表达头字段描述了封装在消息体的数据表
    达，如果相同的请求是GET。

    以下头字段传达了表达元数据：
    +-------------------+-----------------+
    | Header Field Name | Defined in...   |
    +-------------------+-----------------+
    | Content-Type      | Section 3.1.1.5 |
    | Content-Encoding  | Section 3.1.2.2 |
    | Content-Language  | Section 3.1.3.2 |
    | Content-Location  | Section 3.1.4.2 |
    +-------------------+-----------------+

3.1.1.处理表达数据

3.1.1.1.媒体类型

    HTTP在Content-Type(3.1.1.5章节)使用互联网媒体类型[RFC2046],使用Accept头字段
    用来提供开放和可扩展数据类型和类型协商。媒体类型同时定义了数据格式和多种处理
    模式：如何依据每个接收的上下文处理理数据。

    media-type = type "/" subtype *( OWS ";" OWS parameter )
    type       = token
    subtype    = token

    type和subtype可以跟随键值对形式的参数(name=value)。

    parameter = token "=" ( token / quoted-string )

    type,subtype以及参数名称标记大小写不敏感。参数值可能区分大小写，也可能不区
    分，这个依赖于参数名称的语义。参数的存在与否对媒体类型的处理可能很重要，取
    决于在媒体类型注册表中的定义。

    可以将与标识符匹配的参数值作为标识符传输或使用带引号的字符串。引号和不带引
    号是一样的。如以下例子，所有都是同样的意识，但为了一致性首选第一个：

    text/html;charset=utf-8
    text/html;charset=UTF-8
    Text/HTML;Charset="utf-8"
    text/html; charset="utf-8"

    参照[BCP13]定义媒体类型应当在IANA注册。

    注意：与其它头字段中的类似结构不同，媒体类型参数在"="周围不允许空白字符。

3.1.1.2.字符集

    HTTP使用字符集名称表示或协商字符编码方案[RFC6365].字符集标识大小写不敏感。

    charset = token

    字符集名称应当在IANA注册过。注册定义在[RFC2978].

3.1.1.3.规范化和文本设定

    互联网媒体类型使用规范的形式注册，为了能够在不同编码格式下的系统之间交互。
    通过HTTP的表达选择或是转换应该规范形式，处于多种原因在多功能互联网邮件扩展
    (MIME)[RFC2045]中有所描述。然而，电子邮件部署的性能特征与通用的HTTP和WEB有
    很大的不同。此外，为了与旧的电子邮件传输协议兼容，MIME约束无法应用于HTTP。
    MIME规范要求文本的子类型使用CRLF作为换行符。HTTP允许使用CR或LF表示换行，这
    样的换行符对整个表示都是一致的。HTTP发送者可以生成并且接收者必须能够解析文
    本媒体类型中由CRLF、CR、LF表示的换行符。此外，HTTP中的文本媒体类型不限于使
    用八位13和10分别表示CR和LF的字符集。这种灵活的换行符仅适用于使用符号"text"
    标识的媒体类型；并不应用于"multipart"类型或承载数据体外HTTP元素(例如，头字
    段)。

    如果表示是使用content-coding编码的，那么底层数据在编码前应当使用上面的形式
    。

3.1.1.4.多部分类型

    多功能邮件扩展提供了许多"multipart"类型--消息主体中一个或多个封装表示形式。
    多部分类型共享通云语法，如[RFC2046]5.1.1章节定义，并将边界参数做为媒体类型
    的一部分。消息体本身就是协议元素；在消息体部分发送者必需使用CRLF表示换行符。

    HTTP消息框架不使用多部分边界指示消息体长度，尽管实现生成或处理承载可能会使
    用他们。例如，"multipart/form-data"常用于请求中携带表格数据，如[RFC2388]中
    描述，"multipart/byteranges"类型本文所定义的用于一些206(部分内容)应答
    [RFC7233].

3.1.1.5.Content-Type

    "Content-Type"头字段表示关联表达形式的媒体类型：封装承载消息体或选择的表达
    形式，有消息语义确定。指示的媒体类型同时定义了数据格式和数据应用接收者处理，
    在接收消息语义范围内，解码有由任何Content-Encoding指示的编码内容之后。

    Content-Type = media-type

    媒体类型定义在3.1.1.1.下例：

    Content-Type: text/html; charset=ISO-8859-4

    发送者在生成包含消息体时，应当生成Content-Type表明内容类型，除非不清楚封装
    所使用的媒体类型。如果不存在Content-Type投资端，接收者可以假设类型为：
    "application/octet-stream"([RFC2046]4.5.1章节)或检查数据确定它的类型。

    实际上，站主不是总能正确的配置源服务来提供正确的Content-Type,结果是一些客户
    端检查内容并重设类型。这样做会冒得到错误结果风险，可能会带来额外的安全风险
    (例如，特权升级)。更远的，通过数据检查无法确定发送者的意图：许多数据格式与
    仅在处理语言不一样的的媒体类型一样。鼓励使用者能够提供一种禁用"内容嗅探"的
    方法。

3.1.2.压缩或完整性编码

3.1.2.1.内容编码

    内容编码值是指已经或可以被应用于表示的编码转换。内容编码主要用于允许压缩或
    其它有用的转换表示，而不丢失其基础媒体类型和数据信息。经常的，表示方式以编
    码形式存储，直接传输，仅在最终接收者解码。

    content-coding = token

    所有content-coding值都是非大小写敏感，并应当在"HTTP Content Coding Registry"
    注册，如8.4章定义。它们被用于Accept-Encoding(5.3.4章)和内容编码(3.1.2.2)头
    字段。

    以下content-coding值本规范定义：
    compress(和x-compress):见[RFC7230]第4.2.1章。
    deflate:[RFC7230]见第4.2.2章。
    gzip(和x-gzip):[RFC7230]见第4.2.3章节。

3.1.2.2.Content-Encoding

    头字段"Content-Encoding"表明应用了什么内容编码，超越固有的那些媒体类型，那些
    解码机制被应用，获取数据的媒体类型由"Content-Type"头字段说明。
    Content-Encoding主要用于允许表达的数据在被压缩时，不会丢失其基础媒体类型的
    标识。

    Content-Encoding = 1#content-coding

    例：
    Content-Encoding: gzip

    如果一个或多个编码被应用于表达，发送者应用编码必需生成Content-Encoding头字
    段，并按相应顺序列出编码。另外有关编码参数信息可以由另一个头字段提供，在本
    规范有定义。

    不同于Transfer-Encoding([RFC7230]第3.3.1章节)，在Content-Encoding列出的编码
    是表达的特征；表示是根据编码形式定义的，除非在元数据定义中另有说明，否则有关
    表示的所有其他元数据都与编码形式有关。通常，表示仅在渲染或类似使用之前解码。

    如果媒体类型包换固有编码，例如始终压缩的编码格式，那么它将不会在
    Content-Encoding中重述，及时它碰巧与一个内容编码算法一样。这些内容编码只会
    因为一些奇怪的原因被列出，再次应用以形成表示。同样的，源服务可能选择发布相同
    数据作为多种表达，区别仅在于是否编码定义是Content-Type或Content-Encoding的
    一部分，因为一些用户代理在处理每个应答时行为不同(例如，打开"save as ..."对
    画框，而不是自动解压和展示内容)。

    如果请求消息使用的内容编码对于源服务器来说不可接受，那么可以响应415(不支持
    媒体类型)状态。

3.1.3.读者语言

3.1.3.1.语言标签

    语言标签，定义在[RFC5646]，标识自然说、些、或转换自人类信息交流行为的语言，
    计算机语言明显不在此列。

    HTTP在Accept-Language和Content-Language头字段中使用语言标签。Accept-Language
    使用更广泛的定义在5.3.5章节的语言，而Content-Language使用下面定义的语言。

    language-tag = <Language-Tag, [RFC5646]2.1节>

    语言标签是一个或多个非大小写敏感的子标签序列，每个用连字符隔开("-",%x2D)。
    更多情形，语言标签由主语言子标签组成，字标签表明一个广泛使用的语言(例如，
    "en"=English),随后是一些列可选的子标签，一些使用范围相对较小的语言(例如，
    "en-CA"=加拿大使用的英语)。空白不允许出现在语言标签里。如下标签包含空白：

    fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

    见[RFC5546]更多信息。

3.1.3.2.Content-Language

    "Content-Language"头字段描述目标受众的自然语言。注意，这个并不表示表示中
    的所有语言。

    Content-Language = 1#language-tag

    语言标签定义在3.1.3.1章。Content-Language主要目的是允许用户根据自己喜好语
    言来识别和区分表示。这样，如果内容仅面向丹麦文盲读者，使用值：

    Content-Language: da

    如果没有指定Content-Language，默认情况下，该内容适用于所有语言。这意味着发
    送者不认为它特定于任何一种语言，或者发送者不知道采用何种语言。

    针对多种受众的内容可能采用多种语言。例如，<怀唐伊条约>同时适用原始毛利和英
    语版本，那么就是：

    Content-Language: mi, en

    然而，不能仅仅因为多语言表达就意味着它适用于多种受众。一个例子就是初学者语
    言入门，如"拉丁语第一课"，明显是给英语手受众。此例中，Content-Language将只
    包含"en"。

    Content-Language可以应用于任何媒体 -- 它不限于文本文件。

3.1.4.识别

3.1.4.1.识别表达

    当一个完整或部分表达被传输，通常希望发送者提供，或接收者决定，与该表示相对应
    的标识符。

    请求消息：

    如果请求有Content-Location头字段，则发送者确认断言负载的是Content-Location
    所标识资源的表达。然而，除非有其它证明，这种断言是不可信的。该信息对于历史
    修订链接可能依然有用。

    否则，负载是不明确的。

    应答消息，按顺序应用以下规则直到匹配：

    1.如果请求方法是GET或HEAD，并且应答状态是200(OK),204(No Content),206(Partial
    Content)，或304(Not Modified)，负载是请求URI标识的资源的表达([RFC7230]5.5章)。

    2.如果请求方法是GET或HEAD，并且应答状态是203(Non-Authoritative Information)，
    负载可能被修改了，或是中介提供的目标资源的增强表达。

    3.如果应答存在Content-Location头字段，并值与请求是指向同一个URI，那么负载是
    请求URI所标识资源的表达。

    4.如果应答有Content-Location头字段，但其值与请求URI指向不一样，那么发送者断言
    负载内容是Content-Location的值所标识的资源表达。然而，除非通过其它方式验证，
    这种断言是不可信任的。

    5.否则，负载不明。

3.1.4.2.Content-Location

    Content-Location头字段指向一个URI，可用于标识消息所负载的对应的特定资源。或者
    说，如果GET请求这个URI，然后200(OK)应答将包含同样的负载封装的表达。

    Content-Location = absolute-URI / partial-URI

    Content-Location值是对于有效请求URI是不可替换的([RFC7230]5.5章)。它是表示元
    数据。它与定义在MIME体部分([RFC2557]4章)的相同名字的头字段有着相同的语法、语
    义。然而，它在HTTP消息中对于接收者有着一些特殊的含义。

    如果Content-Location在一个2xx(Successful)的应答消息中，其值指向的URI与请求
    一致，然后接收者可以在消息始发日期指示的时间将有效载荷视为该资源的当前表示。
    对于GET(4.3.1章)或HEAD(4.3.2章)请求，当服务未提供Content-Location时与默认语
    义相同。对于状态改变请求如PUT(4.3.4章)或POST(4.3.3章)，意味着服务响应包含着
    新的资源表达，从而将其与表达形式区分，可能只报告有关操作(例如，"有效!")。这
    允许作者申请更新他们本地副本，而不需要下一个GET请求。

    如果Content-Location在一个2xx(Successful)响应中，其值与请求URI指向不同，源服
    务声称是其它资源的表达。仅当两个资源标识符都属于同一个资源拥有者时，此类声明
    才具有可信度，这个无法通过HTTP编码决定。

    -对GET或HEAD请求的响应，这表明有效请求URI指向内容的资源，Content-Location值
    更具体对选择表达的标识。

    -对于201(Created)响应状态变更方法，Content-Location值表明当前负载的新的资源
    表达的位置。

    -其它，这样的Content-Location表明负载是报告请求状态的表示，同样给定的URI的报
    告是有效的(后用GET访问)。例，通过POST请求交易，可能收到200(OK)响应中负载有收
    据文档；Content-Location值提供同一份文档的标识，以备以后请求。

    用户代理在请求消息中发送Content-Location是表明最初用户是从何处获的内容。换一
    种说法就是用户代理提供了最初资源表达的反向链接。

    原服务器收到请求消息中带有Content-Location字段，必需作为请求的临时上下文处理
    ，而不是作为表达的一部分元数据保存。源服务可以使用这个上下文来指导处理请求，
    或保存起来作为其它用途，如源链接或版本元数据中。然而，源服务一定不能使用这类
    上下文信息来改变请求语义。

    例如，如果客户端PUT请求一个交互的资源，服务器接受PUT(没有重定向)，然后资源的
    新状态应与PUT中提供的一种表达形式一致；Content-Location不能被用来做为反向内
    容选择标识符的一种形式，来更新唯一的协商表达。如果用户代理想要后一种语义，就
    直接将PUT应用于Content-Location的URI。

3.2.表达数据

    与HTTP消息相关的表达数据，做为消息负载主体提供，或消息语义所指和有效的请求
    URI。表达数据的格式和编码由表达元数据头字段定义。

    Content-Type和Content-Encoding头字段决定了表达数据的类型。这些定义了层，有序
    编码模型：

    representation-data := Content-Encoding(Content-Type(bits))

3.3.负载语义

    一些HTTP消息消息负载全部或一部分表达信息。一些情况下，负载可能只含关系表达
    的头字段(例如，HEAD响应)或表达数据的部分内容(例如，206(Partial Content)码)。

    请求中负载目的由方法语义定义。例如，PUT请求的负载表达表示期望目标资源的状态
    ，如果请求成功的话。而POST请求(4.3.3章)中的负载表示的是目标资源要处理的信息
    。

    在应答中，负载目的由请求方法和响应状态码两者定义。例如，对GET请求200(OK)
    应答的负载表示当前目标资源的状态，消息始发日期所关注到的(7.1.1.2),而同样的
    状态码对POST请求响应的负载可能表示处理后的结果或目标资源新的状态。响应是错
    误状态码，通常所含的负载表示错误状况，描述错误状态和建议进一步的解决方法。

    特别描述负载的头字段，而不是相关表示，被称为"负载头字段"。负载头字段在本规
    范的其它部分定义，由于它们影响消息解析。

    +-------------------+----------------------------+
    | Header Field Name | Defined in...              |
    +-------------------+----------------------------+
    | Content-Length    | Section 3.3.2 of [RFC7230] |
    | Content-Range     | Section 4.2 of [RFC7233]   |
    | Trailer           | Section 4.4 of [RFC7230]   |
    | Transfer-Encoding | Section 3.3.1 of [RFC7230] |
    +-------------------+----------------------------+

3.4.内容协商

    当响应传递负载信息是，不管成功或错误，源服务通常有不通的表示方式，例如，用
    不同的格式、语言、编码。同样的，不同的用户或用户代理可能有不同的能力、特点
    或偏好这些会影响表达，最好提供可用的方法。因此，HTTP提供内容协商机制。

    规范定义了内容协商两部分，可以在协议中看到:"proactive"服务器基于用户代理的
    首选项选择表示形式，"reactive"服务器提供表示形式列表由用户代理从中选择。内
    容协商其它部分包括"条件内容"，表示形式由多个部分组成，根据用户代理参数有选
    择性的呈现，"active content"内容是脚本，根据用户代理特点提出额外(更具体)请
    求,"Transparent Content Negotiation"([RFC2295]),由中介选择。这么模式不是互
    斥的，并每个都在适用性和实用性之间进行权衡。

    注意，在所有情况下，HTTP都不知道资源的语义。源服务响应请求的一致性，随时间
    推移以及内容协商各方面，资源观察到表示相同性，完全取决于任何实体或算法选择
    或生成那些响应。HTTP不关注幕后的人。

3.4.1.主动协商

    用户代理请求中发送内容协商的首选项，由服务器选择表达方式，称为主动协商。与
    请求中提供的各种信息相比，选择基于响应中可用的表达形式(可能会变化的维度，例
    如语言、内容编码、等等)，包括5.3节显示的协商字段和隐式特性，例如客户端网络
    地址或部分用户代理字段。

    当从可用表达中选择的算法较难描述给用户代理时，主动协商就比较有利，或当服务
    器期望给用户代理发送其最好猜测与第一个响应一起(如果最佳猜测足够好，就可以避
    免后面来回请求代理的延迟)。为了改进服务的猜测，用户代理可以在请求头字段中描
    述其首选项。

    主动协商有以下验证缺点：

    -服务器准确对任何用户给出最好的列表是不太可能的，因为需要完全知道用户代理能
    力及响应的趋向用途(如，直接用于屏幕观看或打印?)；

    -让用户代理在每个请求中描述功能是非常低效(假设只有一小部分应答是需要多种表达
    )并且对于用户隐私有潜在风险。

    -让源服务实现和产生应答算法更加复杂。

    -限制了共享缓存对于响应的可重用性。

    用户代理不能一味的依赖主动协商首选项，因为源服务可能未实现对请求资源的主动协
    商，或可能决定发送不符合用户代理首选的响应总比406(Not Acceptable)响应要好。

    通常响应中Vary头字段，表示主动协商中用到了请求信息的那些部分。

3.4.2.反应式协商

    反应式协商(又名，代理驱动协商)，由用户代理选择最佳应答表示形式(不关心响应码)
    ，从源服务初步应答中所包含的替代表示形式列表。如果用户代理不满意出事应答的表
    达形式，可以GET请求一个或多个替代资源，选择基于列表元数据，来获得一个不一样
    表达形式的响应。替代选择可以由用户代理自动选择或用户通过菜单手动选择。

    注意以上提到的应答表示形式，通常来说，不是资源的表示形式。如果响应具有表示目
    标资源的含义，那么替代的表示形式仅被视为目标资源的表示形式(如,200响应GET请求
    )，或具有执行目标资源链接的语义(如，300响应GET请求)。

    服务器可能不会发送初始表示形式，而不是备选列表，从而表示用户代理反应式协商是
    首选。例如，300(Multiple Choices)响应列出替代列表和406(Not Acceptable)包含可
    用表达形式，这样用户或用户代理能够通过选择做出反应。

    当响应随一些因素变化(如类型，语言，或编码)，源服务无法确定用户代理能力，公共
    缓存用于服务分布和降低网络使用，这些情况下使用反应式协商是有利得。

    被动协商的缺点是向用户代理传送替代列表，如果在头部传输会降低用户感知，并需要
    二次请求获取替代的表达形式。此外，本规范未定义支持自动选择机制，尽管不会避免
    该机制被开发为扩展。

4.请求方法

4.1.概要

    请求方法标识是请求语义的主要来源；表示客户端发起请求的目的和期望的成功结果。

    一些头字段可能进一步表达方法语义(第5章)，在这些增加语义与方法不冲突。例如：
    客户端可以发送条件头字段(5.2章)来表示请求目标资源当前状态行为条件(RFC7232).

    method = token

    HTTP最初设计旨在用于分布对象系统的接口。请求方法设想应用于目标资源，类似代用
    标识对象定义的方法。方法标识大小写敏感，因为可能被用于对象系统的网关，而方法
    名称可能是大小写敏感。

    不像分布对象，由于统一接口为网络系统提供了更好的可见性和重用性，标准的请求方
    法在HTTP中不针对特定资源。因为统一的接口在网络系统[REST]中可以提供更好的可见
    性和重用性。一经定义，标准方法应用于任何资源都是相同的语义，尽管每个资源自给
    决定实现或是否允许。

    本规范定义了一些标准方法，通常用于HTTP，如下表所示。惯例，标准方法由大写由全
    大写的US-ASCII码定义。

       +---------+-------------------------------------------------+-------+
       | Method  | 描述                                            | Sec.  |
       +---------+-------------------------------------------------+-------+
       | GET     | 传输当前资源目标的表示                          | 4.3.1 |
       | HEAD    | 同GET,但只传输状态行和头部                      | 4.3.2 |
       | POST    | 执行特定资源处理请求的荷载                      | 4.3.3 |
       | PUT     | 使用请求的荷载替换目标资源                      | 4.3.4 |
       | DELETE  | 删除所有目标资源                                | 4.3.5 |
       | CONNECT | 创建与服务器通道由目标资源标识                  | 4.3.6 |
       | OPTIONS | 描述目标资源的通信选项                          | 4.3.7 |
       | TRACE   | 执行消息回环来测试目标资源路径                  | 4.3.8 |
       +---------+-------------------------------------------------+-------+

    所有一般用途服务必需支持GET和HEAD方法。
    所有其他方法都是可选的。

    超出本规范的其它方法，应当在"Hypertext Transfer Protocol (HTTP) Method Registry"
    注册，并有IANA管理保存，如8.1章定义。

    目标资源允许的方法会在Allow头部域列出。然而列表可以动态改变。如果接收到的请求方法
    是服务器不认识或无法实现，服务器应当响应501(未实现)。如果服务器能处理请求方法，
    但不允许访问资源，应响应405(不允许)。

4.2. 同样方法属性

4.2.1. 安全方法
    如果方法本质上是只读那么可以认为方法是"安全"；例如，客户端不请求，不期望源服务器
    目标资源状态。同样，合理使用安全方法是不期望引起任何伤害，丢失，或服务器异常负担。

    这里定义的安全方法不能避免实际实现包含一些潜在伤害的行为，不是完全的只读，或引起一
    些副作用。然而，重要的是客户端没有要求这些额外的行为，也不为此承担责任。例如，在完
    成处理请求响应后，大多数服务器会将请求信息加入到访问日志文件，不管用什么方法，即使
    日志存储可能变满并使服务器崩溃，这也被认为是安全。同样，通过选择网站上广告发起的安
    全请求，通常会产生向广告账户收费的副作用。

    此手册中定义的请求方法，GET,HEAD,OPTIONS,和TRACE都是安全的.

    区别安全和非安全方法的目的是，在使用自动检索和预存工作时，不用担心引起麻烦。此外，
    允许客户端对一些存在潜在不受信的非安全内容的使用时做一定的约束。

    当呈现潜在的行为给用户时，客户端应当区别对待安全和非安全方法，在请求一个非安全时
    用户能被提醒。

    当构造资源的有效URI中的参数具有选择行为效果时，资源拥有者有责任确保行为与请求方法
    的语义保持一致。例如，基于Web的内容编辑软件通常会在查询参数中使用操作，如
    "page?do=delete"。如果资源的目的是执行一个非安全方法，那么资源拥有者必不能或不允许
    执行这样的操作，通过使用一个安全请求方法。否则会引起一个不幸的副作用，当自动化过程
    对每个URI执行GET来进行维护，预取，建立索引，等。

4.2.2. 等幂方法
    如果多次请求的预期效果与单次请求一样，那么可以认为这个请求方法是幂等。本规范定义的
    请求方法，PUT,DELETE,和安全方法都是幂等。

    如安全的定义，幂等属性只用于用户请求；服务可以自由的分别记录每个请求，保存校订控制
    历史，或为每个幂请求实现一些非幂等效果功能。

    幂等方法比较好，因为请求发信通讯失败的时候，就可以自动重新发起请求，这个可以发生在
    客户端能够读取服务器响应之前。例如，客户端发送一个PUT请求，在收到应答前底层链接被
    关闭，这时候客户端就可以建立一个新的链接并重新发起幂等请求。因重复请求只是相同的效
    果，即时初始请求成功了，尽管响应可能不同。

4.2.3. 可缓存方法
    一个请求方法能被称为"可缓存"表明它们的响应结果是允许被存储由于将来复用；具体的需求
    见[RFC7234]。一般，不依赖当前或授权响应的安全方法被定义为可缓存；本规范定义GET,HEAD
    ,和POST为缓存方法，虽然绝大多数的可缓存实现只支持GET和HEAD.

4.3. 方法定义

4.3.1. GET
    GET请求方法传递目标资源当前选择表现。GET是检索信息的主要形式，也是几乎所有性能优化
    的重点。因此，当人们说通过HTTP检索一些信息是，通常是指发起了GET请求。

    极有可能资源标识未远程文件系统文件路径，表现形式是文件内容副本。实际上，这就是很多
    资源的实现方式(有关安全建议见9.1章节)。但是，实际上这没有这种现实。资源的HTTP接口
    就是想对内容对象数的实现，各种数据库的程序化视图，或通向其它信息系统的网关。即使URI
    的映射机制与文件系统绑定，源服务器可能被配置执行请求文件为输入，发送输出作为标识，
    而不是直接传输文件。无论如何，只有源服务器需要知道自己每个资源标识对应实现，每个实
    现如何选择，发送当前目标资源的表现视图作为应答给GET请求。

    客户端可以将GET的语义变更为"范围请求"，通过发送一个表示范围的头部值，请求传输一部分
    选择的结果表示。

    GET请求中的有效荷载没有定义语义；在请求中发送和载体可能会引起一些已经存在的实现而导
    致被拒绝。

    GET请求的响应是可以缓存的；缓存可能用它满足后续的GET和HEAD请求，除非Cache-Control标
    题头字段另有说明([RFC7234]第5.2章).

4.3.2. HEAD
    HEAD方法与GET方法相同，除了服务不能发送消息正文响应(即在标题头部分标记结尾)。服务应
    当发送相同的标题头字段响应HEAD请求就像发送给GET请求一样，除头部负载字段可能被忽略。
    此方法可用来获取选择表示结构的元数据而不用传输结果数据，同时经常用来测试超文本链接的
    有效，可访问，和最近修改。

    HEAD请求中的有效荷载没有定义语义；在请求中发送和载体可能会引起一些已经存在的实现而导
    致被拒绝。

    HEAD请求的响应是可以缓存的；缓存可能用它满足后续的GET和HEAD请求，除非Cache-Control标
    题头字段另有说明([RFC7234]第5.2章).

4.3.3. POST
    POST请求，是目标资源处理请求中所包含的信息，处理根据服务自己定义的语义。例如，POST
    常用于以下功能：
    - 提供数据块，如页面上输入表单，进行数据处理；
    - 将信息发布到公告板，新闻组，邮件列表，博客，或类似的文章；
    - 创建尚未被服务器识别的新资源；
    - 将数据追加到现有的资源中；

    源服务器通过选择适当状态码表示响应语义，结果状态依赖于处理POST请求结果；本规范定义的
    所有状态码都可能在POST响应中收到(例外206部分内容，304未修改，416范围无法满足)。

    如果成功处理POST请求后，源服务器会创建一个或多个资源，那么源服务器应当发送201(创建)
    响应并包含位置的头部域来提供创建主要资源的标志(7.1.2章)，和一个描述请求状态的表示，
    当指向一个新的资源。

    对于POST的响应，只有当它包含明显的新旧度信息时才能被缓存([RFC7234]4.2.1章).但是，POST
    缓存没有广泛实施。这种情况下当源服务器期望客户端能够缓存POST的结果，以一种可以被后
    面GET请求复用，源服务器可以发送一个200(OK)响应，包含结果和一个Content-Location头部
    信息，与POST的有效请求一样URI值(3.1.4.2章)。

    如果处理POST请求的结果相当于一个已经存在资源的表达，源服务器可能重定向用户客户端指向
    资源，通过发送303(查看其它)伴随资源的标识Location field值域。这有益于提供用户客户端
    一个资源标识和通过更适合共享缓存方法传输表达，如果用户客户端没有缓存，则以额外请求为
    代价。

4.3.4. PUT
    PUT请求方法是请求被创建资源状态或用请求中定义的状态进行替换。一个成功的PUT给于的表示
    ，建议后续GET结果相当于发送一个200(OK)应答。但是，不保证状态的改变是可见的，因为目标
    资源可能被其它客户端并行作用，或源服务器可能动态处理，在后续GET请求收到钱。成功的响
    应仅暗示客户端意图被服务器实现，在收到时候。

    如果目标资源没有当前表达，并PUT成功创建了一个表示，源服务器必需通知用户客户端201(创建)
    应答。如果目标资源有当前表达并表达被成功修改，源服务必需发送200(OK)或204(无内容)应答，
    表示成功完成请求。

    源服务器应答忽略PUT请求中无法识别的头部字段(即,不将这些保存为资源的一部分状态)。

    源服务器应当验证PUT表示是否与服务器对目标资源的任何约束一致，该约束不能也不会由PUT修改
    。尤为重要的是，当源服务器使用与URI相关的内部配置，来达到设置GET响应的元数据表示。当
    PUT表示与目标资源不一致时，源服务器应当使它们一致，通过转换表示或改变资源配置，或回复
    适当的错误信息，包含足够的信息来解释说明为什么表示不合适。409(冲突)或415(不支持的媒体
    类型)状态码比较推荐，后者特定于于对Content-Type值得约束。

    例如，一个资源被配置为一致是Content-Type="text/html"并表示PUT是Content-Type="image/jpeg"
    ，源服务器应当执行以下一项操作：
    a.重新配置目标资源媒体类型；
    b.转变PUT表示表示与资源类型一致，然后再保存新资源状态；
    c.拒绝请求，回复415(不支持类型)指出目标资源限于"text/html"，可能包含指向一个其它资源
    链接，一个合适新表达的目标。

    HTTP没有确切定义PUT方法如何影响源服务器状态，除了用户代理请求的意图和源服务器响应的意
    图。没有定义资源可能是什么，无论从那个意义上来讲，除了通过HTTP提供的接口。没有定义如
    何存储资源状态，亦或资源状态改变引起的存储改变，或源服务器如何转换资源状态为表示。通
    常来说，服务器会有意隐藏资源接口背后的实现细节。

    源服务器不得发送验证头字段(7.2章)，例如ETag或Last-Modified字段，在一个成功响应PUT请求
    中，除非请求表示的数据被保存，没有对消息体做任何转换(即，资源新的表示数据与PUT请求接收
    表示的表示数据一致)并验证字段值反应新的表示。这个需求让客户端知道，在内存中保持最新的
    表示信息题即是PUT的结果，因此不需要再次检索源服务器，而新的接收到的验证字段可用于将来
    条件请求，为了避免意外覆盖(5.2章)。

    POST和PUT的基本区别是封闭表示的不同意图。目标资源在POST请求下是依据资源拥有者的意思来
    处理封装的表示，而PUT请求是用封装的表示替换目标资源状态。因此，PUT意图是幂等的并对中介
    是可见的，即使只有源服务器才知道确切的影响。

    正确解释PUT请求，假设客户端知道需要哪个目标资源。客户端选择适当的URI服务，在接收到状态
    变更请求后，应当使用POST方法而不是PUT请求。如果源服务不会将PUT状态更改目标资源并期望
    将其应用到另一个资源，例如资源已经被转移到其它URI，那么源服务器必需发送适当3XX(重定向)
    响应；客户端可能会做出自己的选择是否重定向请求。

    应用于目标资源的PUT请求会对其它资源产生副作用，例如，一文章可能有URI表示"当前版本"，
    与标识特定URI版本分离(不同资源在某一时刻共享与当前版本相同状态资源)。一个成功PUT请求
    对"当前版本"URI可能会创建一个新的资源版本，在改变目标资源状态之外，也可能导致在相关
    资源之间增加链接。

    如果PUT请求包换Content-Range头字段([RFC7233]4.2章)，源服务器必需发送400(错误请求)响应
    ，因为负载很可能只是内容的一部分，被PUT误认为是全部表示。部分内容更新可以通过定位部分
    资源标识状态，大资源的一部分，或通过其它部分定义部分更新的方法(例如，[RFC5789]定义的
    PATCH方法)。

    对PUT方法的响应不可缓存。如果一个成功PUT请求通过缓存，具有一个或多个存储的响应，这些
    存储的响应将是无效的(见[RFC7234]4.4章)。

4.3.5.  DELETE

    DELETE方法请求源服务器删除目标资源和其当前功能之间的关联。有效的，这个方法类似于UNIX
    里的rm命令:表示源服务器URI映射的删除操作而不是删除先前关联的信息。

    如果当前资源有一个或多个当前表示，他们可能也可能不会被源服务器销毁，相关的存储空间可能
    也可能不会被回收，这些完全依赖于资源的性质和源服务器的实现(这些都超出了规范内容)。同样
    的，资源的另外一些实现可能需要去停用或归档，如数据库或网关链接。通常来说，源服务器值允
    许删除那些有预定能完全接受删除操作机制的资源。

    相对的只有少数资源允许DELETE方法，主要用于远程创作环境，用户对其效果有一定指导。例如，
    先前通过PUT请求创建了一个资源，或通过POST请求响应201(创建)后位置头字段表示，可能允许相
    应DELETE请求来取消这些操作。相似的，客户端通过实现用户功能，如版本控制客户端用HTTP远程
    操作，可能使用DELETE，基于假设服务URI空间被设计与版本库相对应。

    如果删除方法成功应用，如果执行成功但尚未颁布回应202(接受)状态，如果执行已颁布并没有更
    多信息提供应回复204(无内容),如果执行已颁布并应答包含状态描述应回复200(完成)。

    DELETE请求消息负载没自由定义语义；DELETE请求发送一个负载消息体可能会引起一些存在的实现
    而拒绝请求。

    DELETE方法响应是不可缓存的，如果DELETE请求通过缓存存储一个或多个有效请求URI响应，这些
    响应将是无效的([RFC7234]4.4章)。

4.3.6. CONNECT

    CONNECT方法请求接收者建立与发送者源服务器的隧道，有请求目标标识，如果成功，之后限制其
    为数据包的盲目转发，双向的，知道隧道被关闭。隧道常用于创建端对端虚拟链接，通过一个或多
    个代理，然后可以使用TLS对其进行保护(Transport Layer Security,[RFC5246]).

    CONNECT仅用于对代理的请求。源服务器接收到CONNECT请求可能会回应2xx(成功)表示链接建立。
    然而，大部分源服务器不实现CONNECT。

    客户端发送CONNECT请求必需发送请求目标的授权表([RFC72305.3章])；即，请求目标包含隧道目
    标的主机名和端口，冒号隔开。例如：

    CONNECT server.example.com:80 HTTP/1.1
    Host: server.example.com:80

    收件代理可以直接连接请求目标建立隧道，或如果使用其它代理，通过转发CONNECT请求下一站代
    理。任何2xx(成功)响应表示发送(和所有入站带出)将立即切换入隧道模式，在断定成功应答的头
    部空行之后；空行之后接收到的数据来至于请求目标所标识的服务器。任何成功之外的应答表明隧
    道没有形成并链接保持HTTP。

    当隧道中介检测到任何一方关闭链接，那么就关闭隧道：中介必需尝试将封闭端发送的未完成传输
    的数据发送给另一端，关闭两边链接，然后丢弃任何保留的未交付的数据。

    代理身份验证可以用于建立创建隧道的授权。例如，

    CONNECT server.example.com:80 HTTP/1.1
    Host: server.example.com:80
    Proxy-Authorization: basic aGVsbG86d29ybGQ=

    建立通往任何服务器的隧道存在很大危险，特别是知名目的地或保留的TCP端口，不适于WEB同性。
    例如，连接到"example.com:25"请求目标建议代理连接向保留端口以进行SMTP通信；如果允许，这
    可能会诱使代理中继垃圾邮件。支持CONNECT代理应当把使用限制为一组有限已知端口或安全请求
    目标的可配置白名单。

    服务器在;2XX(成功)响应CONNECT中不得发送任何Transfer-Encoding或Content-Length头字段。客
    户端必需忽略任何Content-Length或Transfer-Encoding头字段在CONNECT的成功响应中。

    CONNECT请求中消息负载题没有定义语义；发送消息体可能会引起一些已存在的实现导致拒绝请求。

    CONNECT方法响应不可缓存。

4.3.7.  OPTIONS

    OPTIONS方法是请求目标资源通讯可选项信息，在原始服务器或中介。此方法允许客户端决定资源相
    关的选项或需求，或服务器能力，不需要采取资源行动。

    OPTIONS请求request-target值使用"*"号([RFC7230]5.3章)适用于服务器，而不适用特定资源。因为
    服务器的通讯选项通常取决于资源，"*"请求仅用于类似"ping"或"no-op"类型的方法；除了允许客户
    端测试服务器能力外，别无用处。例如，测试代理服务器HTTP/1.1一致性(或缺失)。

    如果请求目标不是"*"号，OPTIONS请求适用于与目标资源通讯时可用选项。

    服务器生成成功对OPTIONS响应，应当发送任何可能表明服务器实现的选项特性头字段，适用于目标
    资源的(即允许),包含扩展的未在本规范规定的潜在特性。响应消息负载内容，如果有的话，可以描
    述通讯选项，使用机器或人类语言表示。此类表示并未在本规范定义标准格式，但可能会在将来定义
    。如果无负载消息体那么必需生成Content-Length字段值为"0"。

    客户端可以发送Max-Forwards头字段，以指定请求链的接收者为目标(5.1.2章).代理在转发请求时
    不可生成Max-Forwards头字段，除非收到带Max-Forwards字段的请求。

    客户端生成一个包含负载信息题的OPTIONS请求时，必需发送Content-Type头字段表明表达的媒体类
    型。虽然本规范没有定义消息体的任何用处，未来可能扩展OPTIONS消息体，对目标资源做更详细的
    查询。

    OPTIONS方法的响应不可缓存。

4.3.8.  TRACE

    TRACE方法是请求远程应用层的请求消息回送。最终接收者应当反映收到的消息，除以下描述的一些
    字段，作为消息体正文200(OK)回送给客户端，Content-Type为"message/http"([RFC7230]8.3.1章)
    。最终接收者是源服务器或第一个收到Max-Forwards为0的服务器(5.1.2章)。

    客户端不可以生成头字段包含一些敏感数据，有可能会被响应公开。例如，客户端发送用户认证或
    cookies信息是极其愚蠢的。最终接收者应在生成响应消息体正文时应当排除任何请求头字段，像这
    些包含敏感数据。

    TRACE允许客户端看到另一端收到了什么，用这些测试或调试信息。通过头字段设定的值([RFC7230]
    5.7.1章)非常有用，因为其充当了请求链的痕迹。使用Max-Forwards头字段允许客户端限制请求链
    的长度，对于调试代理链无限循环转发消息非常有用。

    客户端不可以在TRACE请求中发送消息体正文。

    TRACE方法的响应不可以缓存。

5.  请求头字段

    客户端发送请求头字段，提供更多有关请求上下文信息，请求条件基于目标资源状态，建议响应的首
    形式，提供授权认证，或修改预期请求处理。字段充当请求修饰符，类似于程序调用方法中的参数。

5.1.    控制

    控制请求头字段，指示对请求的特定处理。

    +-------------------+--------------------------+
    | Header Field Name | Defined in...            |
    +-------------------+--------------------------+
    | Cache-Control     | Section 5.2 of [RFC7234] |
    | Expect            | Section 5.1.1            |
    | Host              | Section 5.4 of [RFC7230] |
    | Max-Forwards      | Section 5.1.2            |
    | Pragma            | Section 5.4 of [RFC7234] |
    | Range             | Section 3.1 of [RFC7233] |
    | TE                | Section 4.3 of [RFC7230] |
    +-------------------+--------------------------+

5.1.1.  Expect

    "Expect"预期头字段表示一组特定行为(期望)，需要服务器支持以正确处理请求。本规范仅有定义
    的预期是100-continue。

    Expect = "100-continue"

    字段值是大小写敏感。

    服务器在接收到不是100-continue的期望值时，可以回应417(期望失败)状态表明出乎意料的期望
    无法实现。

    100-continue告知接收者，客户端会发送一个(大概很大)消息体，并期望接收到100(继续)的临时
    回应，如果请求行和头字段不足以立即获得成功，重定向，或错误响应。允许客户端等待指示，
    在做之前确认值得发送消息体，这样能够提供效率，当消息体很大或客户端预期可能发送错误时
    (例如，当发送一个状态修改方法，第一次，没有在前面确认授权认证)。

    例如，请求由此开始

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue

    在客户端开始填充管道传输数据前，允许源服务器立即响应错误信息，如401(未授权)或405(不允许
    的方法)。

    要求客户端：

    -请求不包含消息正文时，不能生成100-continue期望。
    -发送请求消息体正文前，等待100(继续)响应的客户端必需发送Expect包含100-continue期望。
    -发送100-continue客户端不需要等待特定时长；即使没有收到响应也可以发送消息体。此外，由于
    不能通过HTTP/1.0中介发送100(Continue)，客户端不应当无限期等待响应。
    -客户端在收到417(期望失败)后，重复请求时不再使用100-continue，因为417响应表明响应链不支
    持期望(例如，通过HTTP/1.0服务).

    要求服务器：

    -服务器收到通过HTTP/1.0的100-continue期望请求时必需忽略这个期望。
    -服务器可能忽略发送100(Continue)响应，如果它准备好接收一部分或全部请求的消息体正文，或
    框架表明没有消息体。
    -响应100(Continue)响应服务器最后必需发送最终状态码，一旦消息体正文接收，处理完成，除非
    链接过早关闭。
    -在读取完整个消息体前，服务器就回应了终止状态，此时响应中应当表明服务器是要关闭链接还是
    继续读取并抛弃请求消息([RFC7230]6.6章).

    收到基于HTTP/1.1(或更高)请求行和完整头部包含100-continue期待，表明随后即将是请求消息体
    ，此时服务器必需立即回应，要么终结状态，如果通过检查请求行和头字段就能决定，或回复100-
    continue让客户端发送请求消息正文。源服务器不可在发送100(Continue)回应前等待消息体正文。

    同样的代理服务器这种情况下，要么立即发送终结状态码，或转发请求到下一站。如果代理确信下
    一站服务只支持HTTP/1.0，那么代理可能生成一个100(Continue)回应让客户端开始发送消息体。

        注意：期望字段在原版HTTP/1.1[RFC2068]之后添加，同时意味着即请求100(Continue)响应，
        也指示必需理解的扩展的一般机制。然而，客户端尚未使用扩展机制并大部分服务器也没有实
        现必需理解需求，使得扩展机制并没有起来。本手册就移除了扩展机制以便简化定义和处理
        100-continue.

5.1.2.  Max-Forwards

    Max-Forwards字段,给TRACE(4.3.8)和OPTIONS(4.3.7)请求方法提供了限制请求被代理转发次数的
    机制。主要用于客户端尝试跟踪请求出现失败或循环中间链

        Max-Forwards = 1*DIGIT

    只是十进制数，表明请求还可以被转发的次数。

    每个收到TRACE或OPTIONS请求中介，看到Max-Forwards字段时，在转发请求前必需检查并更新它。
    如果收到的值是0，中介不可在转发请求；而是作为终结接收并响应。如果收到的值大于0，中介
    必需在转发消息前更新值，递减1，或接收者最大支持数。

    对于其他请求方法接收者可能会忽略Max-Forwards字段。

5.2.    Conditionals

    HTTP条件请求头字段[RFC7232]允许客户端设置目标资源的状态做前提条件，如果前提条件不满足
    ，那么响应的请求方法将不执行。本规范定义的每个条件由以下组成，从目标资源所选的当前表示
    状态验证者和先前表示验证者之间比较。因此，这些前提条件评估目标资源是否已改变，从客户端
    所知道被给的状态对比。评估想过依赖于方法语义和选择的条件，定义在[RFC7232]第5章。

    +---------------------+--------------------------+
    | Header Field Name   | Defined in...            |
    +---------------------+--------------------------+
    | If-Match            | Section 3.1 of [RFC7232] |
    | If-None-Match       | Section 3.2 of [RFC7232] |
    | If-Modified-Since   | Section 3.3 of [RFC7232] |
    | If-Unmodified-Since | Section 3.4 of [RFC7232] |
    | If-Range            | Section 3.2 of [RFC7233] |
    +---------------------+--------------------------+

5.3.    Content Negotiation

    主动协商的许多请求头字段都使用一个公共参数，"q"(东小写敏感),为相关内容类型设置偏好权重
    。被称为"质量值"，因为服务器配置也经常使用同样的参数名，为相关选择资源分配权重值。

    权重通常是个0-1的实数，0.001是最低偏好，1最高；值0表示"不可接受"。如果没有"q"参数，默认
    值是1.

     weight = OWS ";" OWS "q=" qvalue
     qvalue = ( "0" [ "." 0*3DIGIT ] )
            / ( "1" [ "." 0*3("0") ] )

    发送qvalue不可生成小数位数超过3的值。用户配置也应当做相同的限制。

5.3.2.  Accept

    Accept头字段用于客户端指出可接受的响应媒体类型。指出请求特别限于一小部分需求类型，就像
    要求在线图像。

     Accept = #( media-range [ accept-params ] )

     media-range    = ( "*/*"
                      / ( type "/" "*" )
                      / ( type "/" subtype )
                      ) *( OWS ";" OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]

    "*"星号符用于将媒体类型分组变为范围，"*/*"表明所有媒体类型，"type/*"表明type下的所有子
    媒体类型。媒体范围表明适用于该范围的类型参数。

    每个媒体范围后可能跟0或更多适用的媒体类型参数(如字符集)，可选"q"参数表明相关权重(5.3.1)
    ，0或扩展参数。如果任何扩展出现那么"q"参数是必需的，因为它充当两个参数的分隔符。

        注意：适用"q"参数分隔媒体类型是由于历史惯性。尽管可以防止任何用"q"命名的参数与媒体
        范围一起适用，考虑到IANA中缺少"q"参数，这种事情不太可能发生，并不鼓励适用用"q"注册
        为媒体类型

    例：Accept: audio/*; q=0.2, audio/basic
    表示"我偏好audio/basic类型，但是发送给我任何audio，如果质量在降低80%之后。"

    如果请求没有Accept头字段暗示着客户端可以接受任何媒体类型。如果有头字段，没有任何一个可
    接受的媒体类型可以用来响应，源服务器要么发送406(不可接受)回复或当做未经内容协商忽略头
    字段然后回复请求。

    更详尽的例子： Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c

    口头上，这被解释为"text/html和text/x-c是同等级的首选项，但是如果不存在，那么就使用
    text/x-dvi表达，最后才是用text/plain".

    媒体范围可以被更具体的范围覆盖，或具体的媒体类型覆盖。如果多个媒体范围应用，那么更具体
    的项具有优先权。例如：Accept: text/*, text/plain, text/plain;format=flowed, */*
    优先级如下：
    1.text/plain;format=flowed
    2.text/plain
    3.text/*
    4.*/*

    给定类型关联的权重因子是由，找到优先匹配类型媒体类型范围决定。例如，
    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4,
    */*;q=0.5
    将有以下关联值：
    +-------------------+---------------+
    | Media Type        | Quality Value |
    +-------------------+---------------+
    | text/html;level=1 | 1             |
    | text/html         | 0.7           |
    | text/plain        | 0.3           |
    | image/jpeg        | 0.5           |
    | text/html;level=2 | 0.4           |
    | text/html;level=3 | 0.7           |
    +-------------------+---------------+

    注意：用户代理可能提供某些媒体范围默认权值集。然而，除非客户端是一个封闭系统无法与其他
    呈现代理交互，否则默认应使用当由用户配置。

5.3.3.  Accept-Charset

    Accept-Charset是用户代理发送表明文字内容响应可以接受的字符集。这个字段允许用户代理能够
    理解更全面或专业字符集，告知源服务器该能力。

    Accept-Charset = 1#( ( charset / "*" ) [ weight ] )

    字符集名称定义在3.1.1.2章节。用户代理可能会为每个字符集关联权重，表明用户首选字符集，
    如5.3.1.章节定义，例：Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

    特殊值"*"，如果出现在Accept-Charset字段值中，匹配任何未在值中出现的字符集。如果没有"*"
    表示没有出现的字符集都是不可接受的。

    如果请求没有Accept-Charset头字段，暗示用户代理可以接受任何字符集。多数一般用途用户代理
    不会发送Accept-Charset，除非特别配置了要这样做，因为一个详细的支持字符集列表，让服务器
    很容易识别个人，通过用户代理请求特征(9.7章)。

    如果发送了Accept-Charset头字段，而服务器没有任何一个可支持的字符集，那么源服务器要么回
    复406(不可接受)响应，或忽略该头字段像未做内容协商然后回应请求。

5.3.4.  Accept-Encoding

    Accept-Encoding头字段表明客户端可接受的内容编码(3.1.2.1章)。"identity"用作"no encoding"
    的同义词，用于不需要编码通信。
    Accept-Encoding  = #( codings [ weight ] )
    codings          = content-coding / "identity" / "*"

    每个编码可能会给出相关权重值，如5.3.1章定义。"*"符号配置未列出的编码。

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

    请求没有Accept-Encoding意味着用户代理对content-codings没有首选项。虽然这样允许服务器使
    用任何content-coding回应，而不意味着用户代理能够正确处理所有编码。

    服务器尝试一个编码是否可被接收，使用如下规则：
    1.如果请求中没有有Accept-Encoding，用户代理被认为可以接受任何编码。
    2.如果表达没有content-coding，那么默认可别接受除非专门由"identity;1=0"或"*;q=0"排除，没
    有更多的"identity"条目。
    3.如果表示的内容编码是Accept-Encoding列出的内容编码之一，那么是可接受的，除非其所伴随的
    权重值为0.(依5.3.1章定义权重值0意识是不可接受。)
    4.如果多个内容编码可被接收，那么优先非零的最高权重值。

    合并字段值为空的Accept-Encoding头字段意味着用户代理不想要任何内容编码。如果请求有Accept
    -Encoding而没有任何一个表达在可接受列表，源服务器应当回应没有用编码的响应。

        注意：大部分HTTP/1.0应用不认识或不服从内容编码权重值。意味着权重值可能不起作用，并
        不允许使用x-gzip或x-compress.

5.3.5.  Accept-Language

    Accept-Language头字段用于表明一系列首选的自然语言。语言标签定义在3.1.3.1章。

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               <language-range, see [RFC4647], Section 2.1>

    每个语言范围可以关联权重值，例如，
    Accept-Language: da, en-gb;q=0.8, en;q=0.7
    意思："优先Danish,可以接受British英语或其他类型英语".

    请求没有Accept-Language表示可以接受任何语言的响应。如果有头字段，但没有任何一个匹配的
    语言标签，源服务器可以忽略字段然后当做没有进行内容协商进行回复，或者返回406
    (Not Acceptable)响应。虽然，不鼓励适用后者，因为如果这样做就阻止了用户可能使用(例如：
    翻译软件)访问内容。

    注意，一些接收则可能将列出语言标签的顺序视为降序优先级，尤其是那些被分配了相同权重值得
    标签(没有值是1)。虽然，这种行为不可作为依赖。为了一致性和最大化互通性，很多用户代理会
    为标签分配唯一的权重值，并用权重的降序排列。附加的语言优先级讨论[RFC4647]2.3章节。

    为了匹配，[RFC4647]第3章定义的集中匹配方案。实现可以为其需求提供最合适的匹配方案。
    "Basic Filtering"方案([RFC4647],3.3.1部分)与之前[RFC2616]14.4章节定义的匹配方案是相同
    的。

    每个请求都发送完整语言首选项，可能与用户隐私相悖(9.7章)。

    由于可理解性高度依赖于用户个人，客户代理必需允许用户重置语言首选项(要么通过用户代理配置
    或默认为用户可控操作系统设置)。没有向用户提供这些控制的用户客户端不可以发送
    Accept-Language头字段。

        注意：由于用户不熟悉语言匹配细节，在配置时客户端应当提供指引。例如，用户假设会选择
        "en-gb"，如果没有英式英语，他们获得任何种类的英文文档。用户代理可能建议，在这种情况
        下，增加"en"到列表中会有更好的效果。

5.4.    身份认证

    有两个头字段用来放身份认证，定义在[RFC7235].注意为用户认证的多种自定义机制用Cookie头字段
    。如下面定义[RFC6265]

    +---------------------+--------------------------+
    | Header Field Name   | Defined in...            |
    +---------------------+--------------------------+
    | Authorization       | Section 4.2 of [RFC7235] |
    | Proxy-Authorization | Section 4.4 of [RFC7235] |
    +---------------------+--------------------------+

5.5.    请求内容

    接下来的请求头字段提供额外的请求内容信息，包含的信息有关用户，用户代理，和请求背后资源。
    +-------------------+---------------+
    | Header Field Name | Defined in... |
    +-------------------+---------------+
    | From              | Section 5.5.1 |
    | Referer           | Section 5.5.2 |
    | User-Agent        | Section 5.5.3 |
    +-------------------+---------------+

5.5.1.  From

    "From"头字段包含了一个电子邮箱地址，是控制请求客户端的用户的。这个地址应当是机器可用，
    如[RFC5322]的3.4章节定义的：
        Frorm = mailbox
        mailbox = <mailbox, [RFC5322]，3.4部分>

    例如：From: webmaster@example.org
    From头字段很少被非机器客户端发送，在没有用户明确配置时，用户代理不应当发送此字段，因为
    这与用户隐私或站点安全冲突。

    机器代理应当发送From头字段，这样负责运行机器的人，如果在服务器发生问题是就能够被联系到，
    例如机器人发送过多，不必要或无效的请求。

    服务不应当使用From字段来访问控制或身份，因为多数接收者会假设此字段值是一个公共信息。

5.5.2.  Referer

    Referer头字段是客户端用来指明资源URI是来自于哪个目标URI(即，推介人referrer，虽然字段名
    拼写错了)。客户端不可以包含片段和URI参考的用户信息组成[RFC3986]，如果有的话，生成字段
    值。

        Referer = absolute-URI / partial-URI

    Referer头字段允许服务器产生指向其他资源的反向链接以进行简单分析，日志，优化缓存，等。
    还允许查找过时的或类型错误链接用于维护。一些服务器使用头字段，拒绝来自其他网站的链接
    (所谓"深层链接")或限制跨站点请求伪造(CSRF)，但不是所有请求都包含。

    例：Referer: http://www.example.org/hypertext/Overview.html
    如果请求目标URI来自于一个没有自己URI资源(例如，用户键盘输入，或来自用户收藏或书签)，
    用户代理必需要么排除Referer字段或发送值为"about:blank".

    Referer字段有潜在透露用户请求内容或浏览历史，如果资源表明透露用户个人信息(例如账号)或
    资源支持认证机密(如防火墙后面的安全服务器)。大部分一般用途客户端不会发送Referer字段当
    推介资源是一个本地"file"或"data"文件。如果推介页是个安全协议那么用户客户端不可在非安
    全HTTP请求中发送Referer字段。相关的安全注意事项9.4章。

    一些已知的中介会不加选择的从出请求中移除Referer字段。不幸的是这种做法干扰了对CSRF攻击
    的防护，会让用户受到更大伤害。希望限制披露的中介和用户客户端应当把限制改为特定编辑，
    例如用化名替代域名或截断查询并、或路径组成。当字段值与请求目标共享同样的方案和主机时，
    中介不应修改或删除Referer字段。

5.5.3.  User-Agent

    User-Agent字段包含有关发起请求用户客户端信息，常用用于帮助服务器确定报告互通性问题，解
    决或定制回应避免特定用户客户端限制，用于分析有关浏览器或操作系统使用。用户客户端应当发
    送User-Agent字段在每次请求是，除非特别配置了不要这么做。
        User-Agent = product *( RWS ( product / comment ) )
    值组成由一个或多个产品标识，每个可伴随零或多个注释([RFC7230]3.2章)，共同标识用户代理软
    件和重要的子产品。按惯例，产品标识符按其重要性降序排列，以标识用户代理软件。每个产品标
    识由名称和可选版本组成。
         product         = token ["/" product-version]
         product-version = token
    发送者应当将生成产品标识符限制在需要标识的内容内；不得在信息中生成广告或其他非必要信息
    。发送者不用当生成不是版本信息标识符在产品版本中(即，同一产品名称的后续版本，仅在产品
    标识符部分不同)。
    例如：User-Agent: CERN-LineMode/2.15 libwww/2.17b3

    用户代理不应生成包含无必要的细粒度的信息，应当限制第三方额外的子产品。过长详细的值会增
    加请求等待时间并存在被识别的风险。

    同样的，实现不鼓励使用其它的产品的标示，以宣布对其它产品的兼容，这样就绕开了字段的目标
    ，如果用户代理伪装成其它地理，接收者就可以假设客户端期望收到与伪装客户端一样的定制的响
    应，即使它们可能处理的与其它客户端一样好。

6.  响应状态码

    状态码是一个三位数字代码，给与满足请求结果，及尝试理解。

    HTTP状态码是可扩展。客户端不需要理解所有注册的状态码，尽管这样做是可取的。然而，客户端
    必需理解任何状态码的类别，如第一个数字的意思，将不识别的代码处理为等同于x00类的状态码，
    除了不能缓存无法识别的状态码之外。

    例如，客户端收到了一个无法识别的状态码471，客户端可以假设请求内容有问题并如400一样处理
    响应。响应通常包含解释状态的信息内容。

    第一位定义响应类别。后两位没有任何分类作用。第一位有5个值：
    -1xx(信息):请求已经收到，持续处理。
    -2xx(成功)：请求成功收到，理解，并接受。
    -3xx(重定向)：需采取进一步行动，以完成请求
    -4xx(客户端错误)：请求存在错误语法或不可完成。
    -5xx(服务端错误)：服务器处理失败看似有效请求。

6.1.    状态码概要

    以下列出的状态码定义在本手册，[RFC7232]第4章，[RFC7233]第4章，[RFC7235]第3章。这里列出
    原因仅是建议，他们可以被本地等效替换而不影响协议。

    默认定义为可缓存的响应状态码(例如，200, 203, 204, 206, 300, 301, 404, 405, 410, 414
    , 501)可以由启发式缓存重用，除非方法定义另有说明，或显示缓存控制[RFC7234]；所有其他默认
    不可缓存。

       +------+-------------------------------+--------------------------+
       | Code | Reason-Phrase                 | Defined in...            |
       +------+-------------------------------+--------------------------+
       | 100  | Continue                      | Section 6.2.1            |
       | 101  | Switching Protocols           | Section 6.2.2            |
       | 200  | OK                            | Section 6.3.1            |
       | 201  | Created                       | Section 6.3.2            |
       | 202  | Accepted                      | Section 6.3.3            |
       | 203  | Non-Authoritative Information | Section 6.3.4            |
       | 204  | No Content                    | Section 6.3.5            |
       | 205  | Reset Content                 | Section 6.3.6            |
       | 206  | Partial Content               | Section 4.1 of [RFC7233] |
       | 300  | Multiple Choices              | Section 6.4.1            |
       | 301  | Moved Permanently             | Section 6.4.2            |
       | 302  | Found                         | Section 6.4.3            |
       | 303  | See Other                     | Section 6.4.4            |
       | 304  | Not Modified                  | Section 4.1 of [RFC7232] |
       | 305  | Use Proxy                     | Section 6.4.5            |
       | 307  | Temporary Redirect            | Section 6.4.7            |
       | 400  | Bad Request                   | Section 6.5.1            |
       | 401  | Unauthorized                  | Section 3.1 of [RFC7235] |
       | 402  | Payment Required              | Section 6.5.2            |
       | 403  | Forbidden                     | Section 6.5.3            |
       | 404  | Not Found                     | Section 6.5.4            |
       | 405  | Method Not Allowed            | Section 6.5.5            |
       | 406  | Not Acceptable                | Section 6.5.6            |
       | 407  | Proxy Authentication Required | Section 3.2 of [RFC7235] |
       | 408  | Request Timeout               | Section 6.5.7            |
       | 409  | Conflict                      | Section 6.5.8            |
       | 410  | Gone                          | Section 6.5.9            |
       | 411  | Length Required               | Section 6.5.10           |
       | 412  | Precondition Failed           | Section 4.2 of [RFC7232] |
       | 413  | Payload Too Large             | Section 6.5.11           |
       | 414  | URI Too Long                  | Section 6.5.12           |
       | 415  | Unsupported Media Type        | Section 6.5.13           |
       | 416  | Range Not Satisfiable         | Section 4.4 of [RFC7233] |
       | 417  | Expectation Failed            | Section 6.5.14           |
       | 426  | Upgrade Required              | Section 6.5.15           |
       | 500  | Internal Server Error         | Section 6.6.1            |
       | 501  | Not Implemented               | Section 6.6.2            |
       | 502  | Bad Gateway                   | Section 6.6.3            |
       | 503  | Service Unavailable           | Section 6.6.4            |
       | 504  | Gateway Timeout               | Section 6.6.5            |
       | 505  | HTTP Version Not Supported    | Section 6.6.6            |
       +------+-------------------------------+--------------------------+

    注意此列表不是详尽的，不包含其它规定的扩展状态码。完整的列表保存在IANA，详见8.2章。

6.2.    信息 1xx

    1xx(信息性)类型状态码表示通讯连接状态的临时响应或在完成请求执行发送最终响应前请求进度
    。1xx响应终结于状态行后的首个空行(空行表示头部的结束)。由于HTTP/1.0没有定义任何1xx状态
    码，服务不可给HTTP/1.0客户端发送1xx响应。

    客户端必需能够解析一个或多个1xx响应，在最终响应之前，即使客户端不期望有。用户代理可能
    会忽略不期望的1xx响应。

    代理必需转发1xx响应，除非代理自己请求产生的1xx响应。例如，代理增加"Expect:100-continue"
    字段，然后转发请求，这是不需要转发响应的100(持续)响应。

6.2.1.  100 Continue

    100(持续)状态码表示请求的初始部分已经接收到并尚未被服务器拒绝。待完全接收请求并处理后，
    服务器将方法最终响应。

    当请求包含100-continue Expect头字段是，100响应表示服务器期望接收请求的消息体，如5.1.1
    章所述。客户端应当继续发送请求并抛弃100响应。

    如果请求没有带有Expect头字段，客户端可以很简单的抛弃临时响应即可。

6.2.2.  101切换协议

    101(切换协议)状态码表示服务器理解并愿意遵守客户端的要求，通过升级头字段([RFC7230]6.7章
    节)，用来更在应用在此链接上的应用层协议。服务器必需生成Upgrade头字段，这样表明索要切换
    的目标协议，在101响应空行结束后立即切换。

    假设只有在有益的时候服务器才会同意切换协议。例如，切换到一个新的HTTP版本可能比旧版本更
    有又是，并切换到实时，当传递使用此类功能的资源时，同步协议可能会很有用。

6.3.    2xx 成功

    2xx(成功)类型的状态码表示客户端请求成功接收，理解，和接受。

6.3.1.  200 OK

    200(OK)状态码表示请求成功。响应的消息体取决于请求方法。本规范的方法所定义的，消息体的
    目的概括为：
    GET 目标资源的表示；
    HEAD 与GET相同，但没有表示数据；
    POST 行为结果或状态的表示；
    PUT,DELETE 行为状态表示；
    OPTIONS 通讯选项的表示；
    TRACE 最终服务接收到请求消息的表示。

    除了响应CONNECT，200响应始终会有消息体，虽然服务器可能会生成一个零长度的消息体。如果没
    有消息需要，源服务器应当发送204(无内容)替代。对于CONNECT，不允许消息体因为成功的结果是
    一个隧道，在紧跟200响应头部后。

    默认200响应是可缓存；即，除非方法定义另有说明或明确缓存控制(见[RFC7234]4.2.2章)。

6.3.2.  201 创建

    201(创建)状态码表示请求已经被完成，结果是一个或多个新资源被创建。由请求创建的资源由响
    应中的头字段Location标识，如果没有Location字段，则由请求URI决定。

    201响应消息体通常是描述并链接创建的资源。见7.2章讨论验证通字段的含义和目的，如ETag和
    Last_modified在201响应中。

6.3.3.  202 接受

    202(接受)状态码表示请求已被处理接受，但是处理没有完成。请求可能会被执行，也可能不会执行
    ，实际执行时可能不被允许。HTTP中也没有异步操作重新发送状态码的措施。

    202响应是有意的不承诺。目的是允许服务接受一些其它请求的处理(也许是面向批次的处理，
    一天只会运行一次)不需要用户代理持久链接客户端知道处理完成。响应应当描述请求当前状态，并
    执行状态监控器，提供用户何时满足要求的评估。

6.3.4.  203 非权威信息

    203(非权威信息)状态码表示请求成功，但来自于源服务器封装的消息体已经被修改，源服务器回复
    200，然后由代理改变([RFC7230]第5.7.2章)。可以让代理告知接收者消息已经被改变，因为这些可
    能回影响后面内容决定。例如，将来对缓存验证请求可能只适用于同一请求路径(通过同样的代理)。

    203响应类似于警告214转型应用([RFC7234]第5.5章)，优点是适用于任何状态码的响应。

    203响应默认是可缓存；即，除非方法另有定义说明或显示缓存控制([RFC7234]4.2.2章)。

6.3.5.  204 无内容

    204(无内容)状态码表示服务器已经成功完成请求，并且没有附加返回内容。响应头字段的Metadata
    指向目标资源，应用请求操作后，其选定表现形式。

    例如，PUT请求后接受到204响应，响应包含了ETag头字段，此时PUT成功，ETage值包含目前资源新
    表达形式的实体标签。

    204响应允许服务器表明执行已经成功应用在目标资源，同时暗示客户端不需要遍历当前"文档视图"
    (如果有的话)。服务器假设用户代理会向用户提供一些成功的表示，符合它自己的界面，将响应中
    的任何新更新元数据应用到它激活的表现中。

    例如，204状态码常用于文档便面界面响应的"save"操作，这样，保存的文件依然可以被用户编辑。
    同样常用于期望自动进行数据传输的接口一起使用，如分布式版本控制系统。

    204响应结束语头部后首个空行，因为其不可以包含消息体。

    默认204响应是可缓存的；即，除非方法另有定义说明或显示缓存控制([RFC7234]4.2.2章)。

6.3.6.  205 重设内容

    205(重设内容)表明服务已经完成请求并想要用户代理重设"文档视图"，导致发送请求。

    响应旨在支持常见的用户数据输入用例，用户接收到支持数据输入内容(表单，记事本，画布，等)，
    在此空间中输入或操作数据，因数据数据由请求提交，然后输入数据机制被重置为下一次数据准备
    ，以便用户可以轻松启用另一个输入操作。

    由于205响应意味着没有附加内容提供，服务不能生成消息体。换一种说法，服务必需做以下操作
    之一：
    a) 表明0长度消息体，引入Content-Length值是0；
    b) 表明0长度消息体，引入Transfer-Encoding值chunked，消息体单块0长度；
    c) 在发送头部的结束空行后立即关闭链接。

6.4.    3xx 重定向

    3xx(重定向)类型状态码表明用户代理需要采取进一步操作才能满足请求。如果提供了Location头字
    段，用户代理可能自动重定向请求Location指定的地址，即使不清楚具体的状态码。自动重定向需
    要小心如果方法不知道是否安全，如4.2.1章定义，因用户可能不期望重定向非安全请求。

    有几种类型重定向：
    1.  重新导向表明资源可能在其它URI可用，如提供Location字段，如301(永久移动)，302(找到)，
        307(临时重定向)。

    2.  提供多种匹配资源，每个都可以代表原始请求目标，如300(多项选择)。

    3.  重定向到其它资源，由Location表示，可以代表对请求的间接响应，如303(见其它)状态码。

    4.  重定向先前缓存结果，如304(无修改)状态码。

    注意：在HTTP/1.0中301(永久转移)和302(找到)被定义为第一种类型的重定向([RFC1945]9.3章)。
    早起用户代理分别做法是是否使用原有的请求冲顶向到目标或用GET重写。虽然HTTP最初未301和
    302定义了以前的语义(匹配最初CERN实现)，并后来定了了303(见其它)来匹配后来的语义，普遍的
    做法收敛于301和302的后一种语义。HTTP/1.1的第一个版本增加了307(临时重定向)表示前一种语义
    ，而不受不同实践的影响。10多年后，大多数用户代理依然为301和302重写；因此，当原始请求是
    POST时，规范使该方法一致。

    客户端应当检测和干预周期性的重定向(即，无限重定向循环)。

        注意：本规范早起版本推介最大重定向数5([RFC2068]10.3章)。开发者必需知道一些客户端
        可能实现了这个固定限制。

6.4.1.  300 多选项

    300(多选项)表明目标资源有多种表现，每个都有自己具体的标识，并提供有关选项信息，用户可以选择
    偏向的表现，通过重定向请求至一个或多个这样的标识。换一种说法，服务器想要用户代理进行被动式
    协商来选择最需要适合的表现形式(3.4章)。

    如果服务器有首选项，服务器应当生成Location字段包含首选项的URI参考。用户代理可能会使用Location
    值自动重定向。

    对于HEAD以外的请求方法，300响应中服务应当生成消息体，列出表示元数据和URI参数，用户或用户代理
    能够选择一个最合适偏好。如果懂得提供的媒体类型用户代理可能自动选出一个。特定格式的选择没有在
    本规范定义，因HTTP尝试于正交其有效负载的定义。实践中，表示提供易于解析格式，相信较容易让用户
    代理接受，决定于共享设计或内容协商，或一些普遍接受的超文本格式。

    默认300响应是可缓存；即，除非方法定义另有说明或显示缓存控制(见[RFC7234]4.2.2章)

        注意：300代码的原始建议是将URI头字段定义为提供其它表现形式的列表，这样它可以用于200,300，
        406响应并在对HEAD方法响应中进行传输。然而，缺乏部署和预发分歧，导致URI和Alternate(随后提
        案)被放弃。可以使用一组Link头字段来传达列表[RFC5988]，每个都有替代关系，尽管部署是鸡与蛋
        的关系。

6.4.2.  301 永久迁移

    301(永久迁移)状态码表示目标资源已经被分配了一个新的永久URI，以后引用资源都应使用随附的URI之一
    。能够编辑链接的客户端应当自动重连有效的URI，一个或多个服务器响应的引用，在有可能的情况。

    服务应当生成Location包含首选的URI引用指向新的永久URI。用户代理可能使用Location自动重定向。服
    务器响应通常包含消息体包含简短的超文本注释，指向新的URI超链接。

        注意：历史原因，用户代理可能会将POST请求改为GET请求，如果不希望这种结果，可以使用307(临时
        重定向)。

    301响应是可缓存；即，除非方法定义另有说明或显示缓存管理(见[RFC7234]4.2.2章).

6.4.3.  302 找到

    203(找到)表明目标资源临时驻留在其它URI下。由于重定向可能会有机会被修改，客户端在将来请求时应
    当继续用有效请求URI。

    服务应当生成Location头字段包含指向其它URI。用户代理可能会自动重定向Location的值。服务响应消
    息体同上包含简短超文本注释，指向其它URI的超链接。

        注意：由于历史原因，用户代理可能会将POST请求修改为GET在后续请求时。如果不需要这个行为，可
        以使用307状态替代。

6.4.4.  303 见其它

    303(见其它)状态码表明服务重定向用户代理一个其它资源，通过Location表明一个URI，替换提供一个间
    接响应原始请求。用户代理可以执行针对该URI的检索请求(如果用HTTP用GET或HEAD请求)，可能还会得到
    一个重定向，并提供最终结果作为对原始请求的答复。注意新的URI不会被视为等效于有效请求。

    这个状态码可用于任何HTTP方法。它主要用于允许POST的操作输出重定向用户代理到选定资源，因为这样
    做可以以独立于原始请求的方式，提供相应POST响应表单的信息，分别表示，书签，缓存。

    303响应GET请求表明源服务器没有可通过HTTP传输的目标资源的表示。然而，Location值是描述目标资源
    的资源，这样对其它资源发起检所请求可能会得到对接收者有用的表示，并不意味着它能代表原始目标资
    源。注意可以表示的问题答案，什么表示是足够，那些可能有用的描述超出HTTP范围。

    除响应HEAD请求外，响应303的表示应当包含简短超文本注释，伴随着Location提供的同样URI的超文本链
    接。

6.4.5.  305 使用代理

    305(使用代理)状态码定义在前版本，现在不推荐使用(附录B).

6.4.6.  306 (未用)

    306状态码定义在前版本，不再使用，代码当前保留状态。

6.4.7.  307 (临时重定向)

    307(临时重定向)表明目标资源临时在另一个URI下，如果用户代理自动重定向到改URI，不可修改请求方法
    。由于重定向会随时间变化，在将来客户端应当继续使用初始有效的URI。

    服务应当响应带有Location字段，包含重定向的URI。用户代理可能使用Location值自动重定向。响应消息
    体通常包含一个简短的超文本内容，指向新URI的超链接。

        注意：这个状态码类似302(找到)，除了它不允许将POST请求方法改到GET。规范没有为301定义等效的
        对应([RFC7238],但是，为此目的定义308(永久重定向))。

6.5.    客户端错误4xx

    4xx(客户端错误)类型状态码表示客户端似乎有错误。除了响应HEAD请求，服务应当发送表示包含解释错误
    情况说明，以及它是暂时的还是永久的。这个状态可以应用于任何请求方法。用户代理应当展示任何包含
    的表示给用户。

6.5.1.  400 错误请求

    400(错误请求)表明服务器无法处理请求，因为一些客户端错误(例如，异常请求预发，无效的请求消息结
    构，欺骗请求路由)。

6.5.2.  402 需要付款

    402(需要付款)保留将来使用。

6.5.3.  403 禁止

    304(禁止)表明服务器了解请求但拒绝授权。希望公开的服务，为什么请求被拒绝，如果有的话原因会在
    响应消息体中描述。

    如果请求提供了授权认证，服务器认为不足以访问。客户端不应当立即自动重新请求带同样的认证。客户
    端可能重新使用新的或其他认证进行请求。然而，请求被拒绝可能与认证无关。

    源服务如果想希望隐藏当前存在而被禁止的目标资源，可以考虑使用404(未找到)替代。

6.5.4.  404 未找到

    404(未找到)表明源服务器没有找到目标资源的当前表示，或不愿透露存在的资源。4040状态不表示缺少
    的表示是否是临时或永久；如果源服务器知道,可能通过一些配置，这种情况可能是永久的，那么使用
    410(过去的)代码更适合于404.

    404响应可缓存；即，除非方法定义另有说明，或显示缓存控制([RFC7234]4.2.2章)。

6.5.5.  405 不允许的方法

    405(方法不允许)表明目标支援不支持方法。源服务器必需生成Allow头字段包含目标资源当前支持的方法
    列表，回复客户端。

    405响应可缓存；即，除非方法定义另有说明，或显示缓存控制([RFC7234]4.2.2章)。

6.5.6.  406 不可接受

    406(不可接受)表明目标资源没有一个当前表示能够被用户代理接收，按照主动协商(5.3章)，服务器不愿
    提供一个默认的表示。

    服务应当生成消息体，列出可用的表示字符集，用户或用户代理可以选出最合适的资源标识符。用户代理
    可能从中选出一个。然，本手册没有为自动选择定义任何标准，如6.4.1章描述。

6.5.7.  408 请求超时

    408(请求超时)表明在等待时间内服务器没有收到完整的请求消息。服务器应当发送响应"close"链接选项
    ([RFC7230]6.1章)，因为408意味着服务器决定关闭链接而不是继续等待。如果客户端在过程中有未解决
    的问题，客户端可能会在新的链接中重新请求。

6.5.8.  409 冲突

    409(冲突)状态码表明由于目标资源当前状态冲突，请求无法完成。这个状态码用于以下情况，当用户可
    能能解决冲突并重新提交请求。服务器应当生成消息体，充分说明资源的冲突情况。

    响应PUT请求最有可能引起冲突。例如，正在使用版本控制，PUT表示修改资源，同时另一个请求冲突，
    源服务器可能使用409响应表明无法完成请求。这种情况下，响应的消息体很有可能表示包含用于基于历
    史版本合并不同内容的有用信息。

6.5.9.  410 过去的

    410(过去的)表明访问目标不再有用，这种情况可能是永久的。如果服务器不知道，或无法确定，是否是
    永久的情况，应当使用404(未找到)替换。

    410响应主要目的是摆好帮助web维护任务，通知接收者资源不可用，服务拥有者期望删除远程连接。这种
    时间对于限时的促销的服务很常见，还有对于那些属于个人的资源，不再与源服务器有关联。不必将所有
    不可用资源标记为"过去的"，或任何时候都保持这个状态，这个留给服务拥有者自己决定。

    410响应可缓存；即，除非方法定义另有说明，或显示缓存控制([RFC7234]4.2.2章)。

6.5.10. 411 需要长度

    411(需要长度)表明服务器拒绝接受没有给出Content-Length([RFC7230]3.3.2章)的请求。客户端可能在
    增加有效的Content-Length头字段后再次发送请求。

6.5.11. 413 消息过大

    413(消息过大)表明服务拒绝处理请求，原因是消息体太大超出了服务器处理能力或医院。服务器可能关
    闭链接以阻止客户端继续请求。

    如果情况是临时的，服务器应当生成Retry-After来表明情况是临时性的，并在什么时候客户端可重试。

6.5.12. 414 URI过长

    414(URI过长)表明服务器拒绝请求，由于请求目标长度超过了服务解析意愿。这种罕见情况仅可能发生
    在客户端不当的将POST请求转换为GET请求，导致很长的查询信息，当重定向陷入黑洞(例如，重定向URI
    的前缀指向自己的后缀)，或当服务器被攻击客户端试图用潜在的安全漏洞。

    414响应可缓存；即，除非方法定义另有说明，或显示缓存控制([RFC7234]4.2.2章)。

6.5.13. 415 不支持的媒体类型

    415(不支持的媒体类型)表明由于消息体格式不支持目标资源的当前方法。格式问题有可能是由于请求的
    Content-Type或Content-Encoding,或直接检查数据的结果。

6.5.14. 417 失效的期望

    417(失效的期望)表明至少一台入站服务无法满足请求的Expect头字段的期望。

6.5.15. 426 需要升级

    426(需要升级)表明服务器拒绝执行当前协议下的请求，但可能愿意处理客户端升级后另一个写一下的请
    求。服务器必需发送Upgrade头字段表明需要的协议([RFC7230]6.7章)。

    例，服务器需要HTTP/3.0协议：
     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

6.6. 服务器错误5xx

    5xx(服务错误)类型的状态码表明服务器察觉到发生错误或无法执行请求方法。除了当响应HEAD请求，服
    务器应当发送描述解释错误情况，表明是否是临时还是永久性的。用户代理应当向用户展示任何包含的
    表示。这些响应代码适用于任何请求方法。

6.6.1.  500服务内部错误

    500(服务内部错误)服务遇到了意外情况而无法完成请求。

6.6.2.  501 未实现

    501(未实现)服务器不支持请求需要的功能。适用于响应当服务不能识别请求方法，并没有任何资源能力
    提供支持。

    501响应可缓存；即，除非方法定义另有说明，或显示缓存控制([RFC7234]4.2.2章)。

6.6.3.  502 错误的网关

    502(错误的网关)当服务扮演网关或代理，接收到一个来自入站的无效响应。

6.6.4.  503 服务不可用

    503(服务不可用)由于临时超载或计划维护，服务器无法处理当前请求。经过一段时间的延迟这种情况就
    可能缓和。服务器可能发送Retry-After头字段(7.1.3)建议适当的时间后再尝试请求。

        注意：存在的503代码并不意味着服务器在超载时就一定用它。一些服务器可能简单的拒绝连接。

6.6.5.  504 网关超时

    504(网关超时)当服务器作为网关或代理时，没有及时收到上游服务的响应时的状态码。

6.6.6.  505 HTTP版本不支持

    505(HTTP版本不支持)表明服务器不支持，或拒绝支持，请求消息使用的HTTP主版本。服务器表明自己不
    能或不愿使用客户端的主版本完成请求，如[RFC7230]2.6章描述，除了此错误消息。服务器应当生成消
    息体描述为何不支持版本并提供那些支持的协议。

7.  响应头字段

    响应头字段让服务器能够传送有关响应之外的其它信息，而不是状态行中的内容。信息有关于服务器，
    进一步访问的目标资源，或有关资源。

    虽然每个响应头字段都有定义的含义，一般来说，精确的语义可能会被请求方法或响应状态码进一步重
    定义。

7.1.    控制数据

    响应头字段提供控制数据来对状态码做补充，指挥缓存，或指示客户端下一步操作。

    +-------------------+--------------------------+
    | Header Field Name | Defined in...            |
    +-------------------+--------------------------+
    | Age               | Section 5.1 of [RFC7234] |
    | Cache-Control     | Section 5.2 of [RFC7234] |
    | Expires           | Section 5.3 of [RFC7234] |
    | Date              | Section 7.1.1.2          |
    | Location          | Section 7.1.2            |
    | Retry-After       | Section 7.1.3            |
    | Vary              | Section 7.1.4            |
    | Warning           | Section 5.5 of [RFC7234] |
    +-------------------+--------------------------+

7.1.1.  始发日期

7.1.1.1.    Date/Time格式

    1995年以前，有三种不同的常用时间戳格式用于服务通讯。为了与老的实现兼容，这里都会给出说明。
    首先是Internet消息格式[RFC5322]规范使用的固定长度并单区域子集的日期和时间格式。

        HTTP-date   = IMF-fixdate / obs-data

    例：Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

    两种过时的格式：
    Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
    Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format

    接收必需能够解析HTTP头字段中所有的这三种格式的时间戳。当发送者需要生成头字段包含一个或多个
    HTTP-date时间戳时，必需使用IMF-fixdate格式。

    HTTP-date值表示时间是UTC世界标准时间的一个实例。前两种格式通过格林威治标准时间的"GMT"缩写
    表示UTC，UTC的前身；假定上升格式的值采用UTC。发送者用当地时间生成HTTP-date值时应使用NTP
    ([RFC5905])，或一些类似协议其时钟与UTC同步。

    首选格式：
     IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see Section 3.3 of [RFC5322]

     day-name     = %x4D.6F.6E ; "Mon", case-sensitive
                  / %x54.75.65 ; "Tue", case-sensitive
                  / %x57.65.64 ; "Wed", case-sensitive
                  / %x54.68.75 ; "Thu", case-sensitive
                  / %x46.72.69 ; "Fri", case-sensitive
                  / %x53.61.74 ; "Sat", case-sensitive
                  / %x53.75.6E ; "Sun", case-sensitive

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; "Jan", case-sensitive
                  / %x46.65.62 ; "Feb", case-sensitive
                  / %x4D.61.72 ; "Mar", case-sensitive
                  / %x41.70.72 ; "Apr", case-sensitive
                  / %x4D.61.79 ; "May", case-sensitive
                  / %x4A.75.6E ; "Jun", case-sensitive
                  / %x4A.75.6C ; "Jul", case-sensitive
                  / %x41.75.67 ; "Aug", case-sensitive
                  / %x53.65.70 ; "Sep", case-sensitive
                  / %x4F.63.74 ; "Oct", case-sensitive
                  / %x4E.6F.76 ; "Nov", case-sensitive
                  / %x44.65.63 ; "Dec", case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; "GMT", case-sensitive

     time-of-day  = hour ":" minute ":" second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

    过时的格式：
     Obsolete formats:

     obs-date     = rfc850-date / asctime-date

     rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
     date2        = day "-" month "-" 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday", case-sensitive
            / %x54.75.65.73.64.61.79       ; "Tuesday", case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
            / %x54.68.75.72.73.64.61.79    ; "Thursday", case-sensitive
            / %x46.72.69.64.61.79          ; "Friday", case-sensitive
            / %x53.61.74.75.72.64.61.79    ; "Saturday", case-sensitive
            / %x53.75.6E.64.61.79          ; "Sunday", case-sensitive


     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2

    HTTP-date是大小写敏感。发送者不能生成多余的空白超出预发的定义。day-name,day,month,year,
    time-of-day的语义与定义在Internet消息的相同([RFC5322]3.3章)。

    采用rfc850-date格式时间戳的收件人，使用两位数年份，必需解释未来视乎超过50年的时间戳，代表过
    去近几年兵后来位数相同。

    除非字段另有限定，否则鼓励在解释时间戳时保持健壮性。例如，消息偶尔从HTTP往非HTTP资源转发，
    这可能会产生任何Internet消息格式定义的任何日期和时间。

        注意：HTTP仅需要的date/time时间戳用于协议流。不需要用户的表达数据，请求等也实现。

7.1.1.2.    日期

    "Date"头字段表示消息初始日期和时间，与定义在[RFC5322]3.6.1章初始日期(orig-date)含义一样。
    字段值也是一个HTTP-date,如7.1.1.1所定义的。

     Date = HTTP-date

     例：Date: Tue, 15 Nov 1994 08:12:31 GMT

    当生成Date头字段时，发送者应当生成值尽量近似消息生成时间。理论上，时间应当表示消息体生成的
    前的瞬间，实际上，时间可是生成原始消息期间的任意时间。

    如果源服务器无法提供标准时间生成的当前实例时钟，那么不可以发送Date头字段。源服务器可能在响应
    1xx(信息)或5xx(服务错误)类型的状态码时会发送Date头字段。其它情况下源服务器必需发送Date头字段
    。

    存在时钟的接收者，在接收到无Date字段的响应是，必需记录接收的时间，并在缓存或向下游转发时，添
    加到相应的Date字段。

    用户代理可能在请求中发送一个Date头字段，虽然通常不会这么做，除非它被认为将有用的信息传给服务
    器。例如，自定义的HTTP应用可能会传送Date，如果期望服务器通过用户请求和服务器时钟的差异来调整
    对请求的解释。

7.1.2.  Location

    Location头字段用于一些响应用来指出一些与响应有关的资源。关系类型由请求组合方法定义和状态码的
    语义。

     Location = URI-reference

    值由一个单独的URI-reference组成。当他有相对的引用形式([RFC3986]4.2章)，通过针对有效请求URI
    解析来计算最终值([RFC3986]5章)。

    201(创建)响应，Location值指向请求创建的主资源。3xx(重定向)响应，Location值指向自动重定向的
    首选资源。

    如果3xx(重定向)应答中提供的Location值没有分片组成，用户代理必需将重定向当做继承自请求目标分
    片组成一样(即，重定向继承原始指向分片，如果有段话)。

    例如，如GET请求"http://www.example.org/~tim"可能会得到303(见其它)的结果，包含头字段：
        Location: /People.html#tim
    建议用户代理重定向"http://www.example.org/People.html#tim"。

    同样，GET请求"http://www.example.org/index.html#larry"可能得到301(永久转移)包含头字段：
        Location: http://www.example.net/index.html
    建议用户代理重定向"http://www.example.net/index.html#larry",保留原始片段标识。

    在某些情况下，Location值中分片标识符并不合适。例如，201(创建)响应提供URI特定于创建资源。

        注意：一些接收者尝试从Location字段回复，而URI参数是无效的。本规范没有要求或定义此类处理
        ，但确实处于健壮性考虑。

        注意：Content-Location头字段(3.1.4.2)不同于Location指向更具体资源对应封装的表达。因此响
        应可同时包含Location和Content-Location头字段。

7.1.3.  重试-后面

    服务发送"Retry-After"头字段表明需要多久用户代理随后发送请求。当发送503(服务不可用)响应，
    Retry-After表明服务期望客户端等待多久，然后提供服务。当发送3xx(重定向)响应，Retry-After表明
    用户代理要求用户再发出重定向请求等待前的最小时间。

    值可以是HTTP-date或响应收到后的延迟秒数。

     Retry-After = HTTP-date / delay-seconds

    delay-seconds值是非负十进制整数，单位为秒。

     delay-seconds = 1*DIGIT

    两个使用的例子：

     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120
    后面例子是延迟两分钟。

7.1.4.  变化

    Vary头字段描述请求消息，除了方法，Host头字段，和请求目标，可能会影响源服务器处理选择和表达
    响应的部分。值包含一个*号或头字段列表(大小写敏感)。

     Vary = "*" / 1#field-name

    单个"*"号有关请求的任何内容都有可能影响响应表达，可能包含消息语法外的元素(例如，客户端网络
    地址)。在不讲请求转发源服务器的情况下，接收者将无法确定响应对于最新的请求是否合适。代理不
    可生成一个Vary字段值*.

    Vary值由逗号隔开的头字段名称列表，称为选择头字段，可能在选择表现形式是有用。潜在的选择头字
    段并不限定于本规范定义的内容。

    例如，响应包含Vary: accept-encoding, accept-language
    表示源服务器可能会用到请求的Accept-Encoding和Accept-Language字段来决定封装响应内容。

    源服务器发送Vary字段列表可能有两个目的：
    1.  告知缓存接收者，不可用这个响应满足以后的请求，除非后面的请求字段值与此请求值相同
    ([RFC7234]4.1章)。换一种说法，Vary扩大了缓存key需要匹配新的请求到存储缓存条目。

    2.  告知用户代理接收者，此响应需要内容协商(5.3章)，如果随后的请求提供了头字段列表其它参数，
    可能会得到不同的表现结果(主动协商)。

    当选择表达的算法基于除方法和目标以外的请求消息的各方面，源服务器就应发送Vary头字段，除非差
    异无法跨越或源服务器被故意配置为防止缓存透明。例如，因为跨用户重用收到字段定义限制
    ([RFC7234]5.2章)，就不需要发送Authorization字段名。同样的，源服务器可能用Cache-Control替代
    Vary，如果考虑差异不如Vary影响的缓存性能成本重要。

7.2.    验证头字段

    验证头字段传达有关选择的表达的元数据。在回应安全请求响应中，验证者字段描述源服务器处理响应
    是选择的表达形式。注意，依赖于状态码语义，选择的表达形式不一与封装消息体中的表达一致。

    在对状态更改请求成功响应中，验证者描述新的表达形式替换之前选择的表达形式，作为处理请求的结
    果。

    例如，ETag头字段在201(创建)响应传达新创建的资源表达形式的实体标签。这样可用于后续请求请条件
    而避免"lost update"问题[RFC7232].

    +-------------------+--------------------------+
    | Header Field Name | Defined in...            |
    +-------------------+--------------------------+
    | ETag              | Section 2.3 of [RFC7232] |
    | Last-Modified     | Section 2.2 of [RFC7232] |
    +-------------------+--------------------------+

7.3.    怀疑认证

    还以认证机制可以让客户端在将来请求中提供认证凭证。

    +--------------------+--------------------------+
    | Header Field Name  | Defined in...            |
    +--------------------+--------------------------+
    | WWW-Authenticate   | Section 4.1 of [RFC7235] |
    | Proxy-Authenticate | Section 4.3 of [RFC7235] |
    +--------------------+--------------------------+

7.4.    响应上下文

    其余的响应头字段提供更多有关目标资源的信息，以便后续请求可能的需要。

    +-------------------+--------------------------+
    | Header Field Name | Defined in...            |
    +-------------------+--------------------------+
    | Accept-Ranges     | Section 2.3 of [RFC7233] |
    | Allow             | Section 7.4.1            |
    | Server            | Section 7.4.2            |
    +-------------------+--------------------------+

7.4.1.  允许

    Allow头字段表示目标资源支持的一系列方法。目的是严格告知接收者，资源相关的有效请求方法。

        Allow = #method

    例如：Allow:GET, HEAD, PUT

    实际允许的方法值是每次请求时源服务器定义的。在405(方法不允许)响应中，源服务器必需生成Allow
    字段，并可能在其它响应中也这么做。一个空的Allow字段值表名资源没有支持的方法，可能会发生在
    405响应中，当资源配置被临时关闭。

    代理不可以修改允许头字段，它不需要懂得所有的表明方法，以便依照生成消息处理规则进行处理。

7.4.2.  服务

    Server头字段包含有关软件的信息，用于源服务器处理请求，客户端常用它帮助确定所报告的交互性
    问题范围，来解决或调整来避免特定服务器限制，以及有关服务器或操作系统使用情况分析。源服务器
    可能会生成Server字段在响应中

        Server = product *( RWS ( product / comment ) )

    Server值由一个或多个产品标签组成，每个伴随零或多个注释([RFC7230]3.2部分)，一起确定源服务器
    软件或重要的子产品。按惯例，按重要性降序排列。每个产品标签由名称和可选版本组成，如5.5.3章
    定义。

    例：Server: CERN/3.0 libwww/2.17

    源服务器不应生成不必要的更详细的信息，并应当限制其它三方的子产品。过长和详细的Server值会增
    加响应延迟和潜在的揭释内部实现细节，可能让攻击者更容易找到已知的公开的漏洞。

8.  IANA 注意事项

    超文本传输协议方法注册定义请求方法符号命名空间(4章)。方法注意已经被创建并保留在：
    <http://www.iana.org/assignments/http-methods>.

8.1.1.  程序

    HTTP方法注册必需包含以下内容：
    -方法名称(见4章)
    -安全(yes或no,见4.2.1章节)
    -幂等(yes或no，见4.2.2章节)
    -指向规范文本
    添加当这个命名空间值需要IETF检阅(见[RFC5226,4.1章节])。

8.1.2.  新方法注意事项

    当有必要为当前状态码未定义的响应表达语义时，可以注册新的状态码。状态码通用；它们潜在的使用
    与任何资源，不仅一种特别面字体类型，一种类型资源，或HTTP应用。因此，最好将新状态码注册在非
    特定应用的文档中。

    新状态码必需是第6章定义的类别中的一种。要允许现有的解释器处理应答消息，新状态码不能禁止消息
    体，然而可以要求0长度的消息体。

    建议对于尚未广泛部署的新状态码，应当避免分配特定编码，除非明确共识注册；取而代之，初稿可以
    使用符号如4NN或3N0/3N9等等，表明状态码类别而不会过早消耗数字。

    新状态码定义应当说明引起响应的请求情形(例如，请求头字段方法的组合)以及对响应头字段的任何依
    赖(例如，需要哪些字段，什么字段可以修改语义，什么头字段语义与新状态码进一步完善)。

    新定义应当说明是否可缓存。注意如果响应出现新鲜度信息，那么所有状态都是可缓存的；然而，如果
    状态码被定义为可缓存的，那么允许没有显示新鲜度信息的情况下进行缓存。同样的，状态码定义可以
    限制缓存行为。见[RFC7234]更多信息。

    最终，定义应当表明消息体与标识资源有无任何隐式关联。

8.2.3.  注册

    已更新状态注册码：

       +-------+-------------------------------+----------------+
       | Value | Description                   | Reference      |
       +-------+-------------------------------+----------------+
       | 100   | Continue                      | Section 6.2.1  |
       | 101   | Switching Protocols           | Section 6.2.2  |
       | 200   | OK                            | Section 6.3.1  |
       | 201   | Created                       | Section 6.3.2  |
       | 202   | Accepted                      | Section 6.3.3  |
       | 203   | Non-Authoritative Information | Section 6.3.4  |
       | 204   | No Content                    | Section 6.3.5  |
       | 205   | Reset Content                 | Section 6.3.6  |
       | 300   | Multiple Choices              | Section 6.4.1  |
       | 301   | Moved Permanently             | Section 6.4.2  |
       | 302   | Found                         | Section 6.4.3  |
       | 303   | See Other                     | Section 6.4.4  |
       | 305   | Use Proxy                     | Section 6.4.5  |
       | 306   | (Unused)                      | Section 6.4.6  |
       | 307   | Temporary Redirect            | Section 6.4.7  |
       | 400   | Bad Request                   | Section 6.5.1  |
       | 402   | Payment Required              | Section 6.5.2  |
       | 403   | Forbidden                     | Section 6.5.3  |
       | 404   | Not Found                     | Section 6.5.4  |
       | 405   | Method Not Allowed            | Section 6.5.5  |
       | 406   | Not Acceptable                | Section 6.5.6  |
       | 408   | Request Timeout               | Section 6.5.7  |
       | 409   | Conflict                      | Section 6.5.8  |
       | 410   | Gone                          | Section 6.5.9  |
       | 411   | Length Required               | Section 6.5.10 |
       | 413   | Payload Too Large             | Section 6.5.11 |
       | 414   | URI Too Long                  | Section 6.5.12 |
       | 415   | Unsupported Media Type        | Section 6.5.13 |
       | 417   | Expectation Failed            | Section 6.5.14 |
       | 426   | Upgrade Required              | Section 6.5.15 |
       | 500   | Internal Server Error         | Section 6.6.1  |
       | 501   | Not Implemented               | Section 6.6.2  |
       | 502   | Bad Gateway                   | Section 6.6.3  |
       | 503   | Service Unavailable           | Section 6.6.4  |
       | 504   | Gateway Timeout               | Section 6.6.5  |
       | 505   | HTTP Version Not Supported    | Section 6.6.6  |
       +-------+-------------------------------+----------------+

8.3.    头字段注册

    头字段是键值对，用余生小心通信，载体，目标资源，或链接(即，控制数据)。[RFC7230]第3.2章节定
    义了HTTP消息的头字段语法。

    头字段名称的要求定义在[BCP90].

    规范作者建议定义新字段名尽量保持简短使用，并且不要使用"X-"前缀，除非头字段永远不会在互联网
    上使用。("X-"前缀在实际已经被广泛滥用；它旨在用于一种机制，避免专用软件内部名称冲突，或内网
    处理，因此该前缀能够确保私有名称永远也不会与新注册互联网名称冲突；[BCP178]更多信息)。

    新头字段的值通常有自己的语法，使用ABNF(RFC5234)定义,使用扩展定义在[RFC7230]第7章，通常限制
    在US-ASCII字符集范围内。头字段需要更大范围字符集，可以使用一种编码，例如[RFC5987]定义的编
    码。

    原始字段前导和尾随的空白在解析是被删除([RFC7230]3.2.4章)。字段定义值得前导或尾随重要空白，
    需要使用容器语法，例如带引号的字符串([RFC7230]3.2.6章)。

    由于(",")逗号用于键值对间的定界符，如果允许它们在键值对中出现，那么必需小心。通常，可能包含
    逗号的组成部分使用双引号保护。

    例如，一个文字化的日期和URI(任意一个可能包含逗号)可以被安全承载如下：
        Example-URI-Field: "http://example.com/a.html,foo","http://without-a-comma.example.com/"
        Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"

    注意，双引号定界符几乎总是与单引号一起使用；在双引号中使用不同的语法可能会引起不必要的混乱。

    许多头字段使用格式包括(不区分大小写)参数命名(例如，定义在3.1.1.5章的Content-Type).同时允许
    参数值是无引号(令牌)和引号(带引号字符串)语法，使收件者可以使用现有的解析器。当同时允许形式
    ，参数值得意义应当独立于其使用的语法(例如，见处理媒体类型参数注意事项在3.1.1.1章节)。

    规范作者建议定义新头字段考虑记录：
    -   字段是否是单值或是多值列表(用逗号隔开：见[RFC7230]3.2章)。

        如果不使用列表语法，说明如何处理出现多值得情况(直觉上默认直接忽略字段，但这样做可能不总
        是对的选择)。

        注意，中介和软件库可能会将多个头字段实例合并成一个，尽管字段定义不允许列表语法。一个健
        壮的格式可以使接收者发现这种情况(正面例子："Content-Type"，逗号只能出现在带引号的字符串
        内；反面例子："Location",逗号可以出现在URI内).

    -   在什么情况下可以使用字段；例如，只有在响应或请求，在整个消息里，仅在响应特定请求方法，
        等。

    -   是否应由源服务器存储，通过PUT请求了解。

    -   字段语义是否会被上下文进一步细化，例如存在的请求方法或状态码。

    -   字段是否合适列在到Connection头字段中(即，如果头字段是逐跳，见[RFC7230]6.1章).

    -   在什么情况下允许中介写入，删除，或修改字段值。

    -   字段名是否适合列岛Vary响应头字段中(列入，请求头字段用于服务器内容选择算法，见7.1.4章)。

    -   字段是否在尾部有用或允许(见[RFC7230]4.1章)。

    -   字段是否应当跨重定向保留。

    -   是否会引入其它安全问题，例如个人隐私相关数据的披露。

8.3.2.  注册

       +-------------------+----------+----------+-----------------+
       | Header Field Name | Protocol | Status   | Reference       |
       +-------------------+----------+----------+-----------------+
       | Accept            | http     | standard | Section 5.3.2   |
       | Accept-Charset    | http     | standard | Section 5.3.3   |
       | Accept-Encoding   | http     | standard | Section 5.3.4   |
       | Accept-Language   | http     | standard | Section 5.3.5   |
       | Allow             | http     | standard | Section 7.4.1   |
       | Content-Encoding  | http     | standard | Section 3.1.2.2 |
       | Content-Language  | http     | standard | Section 3.1.3.2 |
       | Content-Location  | http     | standard | Section 3.1.4.2 |
       | Content-Type      | http     | standard | Section 3.1.1.5 |
       | Date              | http     | standard | Section 7.1.1.2 |
       | Expect            | http     | standard | Section 5.1.1   |
       | From              | http     | standard | Section 5.5.1   |
       | Location          | http     | standard | Section 7.1.2   |
       | Max-Forwards      | http     | standard | Section 5.1.2   |
       | MIME-Version      | http     | standard | Appendix A.1    |
       | Referer           | http     | standard | Section 5.5.2   |
       | Retry-After       | http     | standard | Section 7.1.3   |
       | Server            | http     | standard | Section 7.4.2   |
       | User-Agent        | http     | standard | Section 5.5.3   |
       | Vary              | http     | standard | Section 7.1.4   |
       +-------------------+----------+----------+-----------------+

    上面注册修改控制者是："IETF(iesg@ietf.org) - Internet Engineering Task Force".

8.4.    内容编码注册表

    "HTTP内容编码注册表"定义了内容编码名称命名空间([RFC7230]4.2章)。内容编码注册表保存在
    <http://www.iana.org/assignments/http-parameters>。

8.4.1.  程序

    内容编码登记必需包含以下内容：

    -   名称
    -   描述
    -   指出规范文本

    内容编码名称不能与传输编码重叠([RFC7230]第4章)，除非编码转换一致(像压缩编码一样[RFC7230]4.2
    章)。

    新添加值需要经过IETF检阅([RFC5226]第4.1章)，并且必需符合本章定义的内容编码的目的。

8.4.2.  注册

       +----------+----------------------------------------+---------------+
       | Name     | Description                            | Reference     |
       +----------+----------------------------------------+---------------+
       | identity | Reserved (synonym for "no encoding" in | Section 5.3.4 |
       |          | Accept-Encoding)                       |               |
       +----------+----------------------------------------+---------------+

9.  安全注意事项

    本章主要想开发者、信息提供者、已知用户说明与HTTP语义有关的安全问题，用于在Internet上的信息
    传输。注意事项有关消息语法，解析，和路由在第[RFC7230]第9章讨论。

    以下列出的注意事项并不详尽。与HTTP语义相关的大部分大多数安全问题都与保护服务端有关(HTTP接口
    背后的代码)，保护用户代理通过HTTP接收消息的处理，或通常安全的使用Internet，而不是协议安全。
    各种组织维护主题信息，并连接到Web应用安全最新的研究(例如，[SWASP]).

9.1.    基于文件和路径名的攻击

    源服务器频繁使用本地文件系统目录，用来管理从有效请求到表达资源的映射。大多数文件系统设计不
    会针对性的防止恶意文件或文件名称。因此，源服务器需要避免访问特别重要的系统名称，当将请求目
    标映射到目标文件，文件夹，或目录。

    例如，UNIX,Windows,和其它操作系统使用".."作为指向当前上级目录的路径，它们使用特殊路命名路径
    或文件名称来向系统设备发送数据。其它类型的存储系统中可能存在类似的命名约束。同样的，本地存
    储系统有个烦人的趋势当处理无效或非预期字符时倾向于用户友好而非安全，分解字符充足，和不区分
    大小名称的名称大小写规范。

    基于此类特殊名称攻击集中于两种拒绝服务(例如，告诉服务器从COM口读数据)或公开配置和源文件不适
    合的送达。

9.2.    基于命令，代码，或查询注入的攻击

    源服务器常使用URI中的参数，标识系统服务，学则数据，或选择数据源。但是，请求中被接收的数据不
    被信任。攻击者可以构建任何请求数据元素(方法，请求目标，请求头，或消息体)来包含可能会被曲解
    未命令，代码或查询的数据，通过一个命令，语言编译，或数据库接口。

    例如，SQL注入是一种常用攻击，其中额外的查询语句被插入到请求目标的一些组成中或头字段中(例如，
    Host, 指引， 等。)。如果收到的数据直接被用于SELECT中，查询语句可能会被解析为数据库命令而不
    是简单的字符串。这种实施漏洞极为常见，尽管很容易避免。

    一般来说，资源的实现应当避免使用请求数据于处理过程上下文或解释为指示。参数应当与固定字符串
    比较和作为比较的结果，而不是通过未准备好的接口传递非信任数据。不基于固定参数的接收数据，应
    当小心过滤或编码避免曲解。

    类似考虑应用于请求数据，当存储和后面的处理，如日志文件，监控工具，或包含允许内嵌于脚本的数
    据格式。

9.3.    披露个人信息

    客户端通常不了解大量用户个人信息，报货用户提供资源交互信息(例如，用户名，地址，邮件地址，密
    码，密钥，等。)和有关用户随时间浏览活动信息(例如，历史，书签，等。)。实现需要防止无意识的披
    露个人用户信息。

9.4.    披露URI中的敏感信息

    URI旨在共享，非安全，即使它们标识是安全资源。URI通常显示在显示器，当打印页面时添加到模板中，
    存储到各种不受保护的书签列表中。因此在URI中包含敏感，个人身份，或披露风险是不明智的。

    服务作者应当避免基于GET形式提交敏感数据，因为这些数据将被置于请求目标中。许多现存的服务器，
    代理，用户代理日志或显示请求目标的地方，可能对于第三方是可见的。因此服务应当使用基于POST形
    式来提交。

    由于Referer头字段将目标网站告知导致请求上下文，它潜在揭露了用户当前浏览历史相关信息和任何
    可能在指引资源URI中被找到的个人信息。Referer头字段的限制被描述在5.5.2章解决一些安全注意事
    项。

9.5.    重定向后披露的片段

    虽然使用于URI参数的片段标识不会在请求中发送，实现应当意识到，它们将可能现鱼用户代理和任何
    扩展或作为响应结果的脚本运行。特别是，当重定向发生，源请求片段标识被新参数继承在Location
    (7.1.2章)，可能有将片段暴露给其它网站的效果。如果第一个网站在片段中使用个人信息，它应当确
    认重定向其它网站所包含的片段组件阻止该继承。

9.6.    披露产品信息

    User-Agent(5.5.3节)，Via([RFC7230]5.7.1节)，Server(7.4.2节)头字段常表明有关各发送者软件系
    统信息。理论上，这样更容易被攻击者利用获知安全漏洞；实际上，攻击者趋于尝试所有潜在漏洞而
    不关心明显软件使用的版本。

    作为穿透网络防火墙服务的代理，应当特别预防有关头信息的转换，这可能标识出防火墙后面的主机。
    Via头字段允许中介使用假名称来替换敏感的机器名。

9.7.    浏览器指纹

    浏览器指纹是一套标识特定用户代理的技术，是随时间推移，通过其独特特征组。这些特征可能包含
    与其TCP行为有关的信息，功能，和脚本环境，虽然特别有趣的一组唯一特征组，可能通过HTTP交流。
    指纹被认为是一个隐私问题，因为它能随时间追踪用户代理行为而没有相应控制，用户可能有其它形
    式的数据收集(例如，cookies).很多一般用途的用户代理(即,Web浏览器)采取了减少指纹措施。

    有一定数量的请求头字段，可能会披露信息给服务器，足够独特能够用于指纹。From头字段是最明显
    的，虽然期望From仅在用户需要自我识别的时候才发送。还有，Cookie头字段故意被设计重新识别能
    力，因此指纹问题仅应用于cookies被关闭或受限于于用户代理配置。

    User-Agent头字段可能包换足够的唯一标识指明设备，通常与其它特征组合，特别是如果用户代理发
    送过多有关用户系统或扩展的详细信息。虽然，独特信息的来源，用户最不期望的是主动协商(5.3章)
    ，包括Accept,Accept-Charset,Accept-Encoding,和Accept-Language头字段。

    除了指纹问题，详尽的使用Accept-Language头字段能披露信息，用户可能被认为私人性质。例如，理
    解给定的语言集可能与特定种族成员密切相关。限制这种隐私丢失的一种方法就是用户代理护忽略发
    送Accept-Language，除了已加入白名单网站，可能通过在检测到表明语言协商的Vary头字后进行交互
    来实现。

    在代理用于增强用户隐私的环境，用户代理应当保守的发送主动协商头字段。一般用途的用户代理提
    供头字段高度配置，应当知会用户提供过于详细信息可能会导致隐私丢失。作为一项极端隐私措施，
    在中继请求中代理可以过滤纸主动协商头字段。

10. 致谢

    见[RFC7230]第10章。

11. 参考